#!/usr/bin/env node
/**
 * IoT Device Scanner
 * Scans IoT devices for security vulnerabilities and misconfigurations.
 */

const net = require('net');
const fs = require('fs');

class IoTDeviceScanner {
    constructor(targetIp) {
        this.targetIp = targetIp;
        this.findings = [];
    }

    scanPorts() {
        console.log(`[*] Scanning ports on ${this.targetIp}...`);
        
        const findings = [];
        const commonPorts = {
            22: 'SSH',
            23: 'Telnet',
            80: 'HTTP',
            443: 'HTTPS',
            1883: 'MQTT',
            8883: 'MQTT over TLS',
            5683: 'CoAP',
            5900: 'VNC',
            8080: 'HTTP Alt',
            8443: 'HTTPS Alt'
        };
        
        const openPorts = [];
        
        return new Promise((resolve) => {
            let completed = 0;
            const totalPorts = Object.keys(commonPorts).length;
            
            Object.entries(commonPorts).forEach(([port, service]) => {
                const sock = new net.Socket();
                sock.setTimeout(1000);
                
                sock.on('connect', () => {
                    openPorts.push({ port: parseInt(port), service });
                    
                    if (service === 'Telnet') {
                        findings.push({
                            severity: 'High',
                            issue: `Telnet Enabled (Port ${port})`,
                            description: 'Telnet is unencrypted and insecure',
                            port: parseInt(port),
                            service: service
                        });
                    }
                    
                    sock.destroy();
                    completed++;
                    if (completed === totalPorts) {
                        resolve(findings);
                    }
                });
                
                sock.on('timeout', () => {
                    sock.destroy();
                    completed++;
                    if (completed === totalPorts) {
                        resolve(findings);
                    }
                });
                
                sock.on('error', () => {
                    completed++;
                    if (completed === totalPorts) {
                        resolve(findings);
                    }
                });
                
                sock.connect(parseInt(port), this.targetIp);
            });
        });
    }

    async scanAll() {
        console.log(`[*] Scanning IoT device: ${this.targetIp}\n`);
        
        this.findings.push(...await this.scanPorts());
        
        console.log('[!] Note: Real implementation would test:');
        console.log('    - Default credentials');
        console.log('    - Firmware version');
        console.log('    - Service-specific vulnerabilities');
        
        return {
            target: this.targetIp,
            findings: this.findings
        };
    }

    generateReport() {
        let report = `# IoT Device Security Scan Report\n\n`;
        report += `**Target Device**: ${this.targetIp}\n\n`;
        
        if (this.findings.length > 0) {
            report += `## Summary\n\n`;
            report += `Total Findings: ${this.findings.length}\n\n`;
            
            const critical = this.findings.filter(f => f.severity === 'Critical');
            const high = this.findings.filter(f => f.severity === 'High');
            const medium = this.findings.filter(f => f.severity === 'Medium');
            
            report += `- **Critical**: ${critical.length}\n`;
            report += `- **High**: ${high.length}\n`;
            report += `- **Medium**: ${medium.length}\n\n`;
            
            report += `## Findings\n\n`;
            this.findings.forEach((finding, i) => {
                report += `### ${i + 1}. ${finding.issue}\n\n`;
                report += `**Severity**: ${finding.severity}\n\n`;
                report += `**Description**: ${finding.description}\n\n`;
                if (finding.port) {
                    report += `**Port**: ${finding.port}\n\n`;
                }
                if (finding.service) {
                    report += `**Service**: ${finding.service}\n\n`;
                }
                report += `---\n\n`;
            });
        } else {
            report += `âœ… No security issues found.\n\n`;
        }
        
        report += `## IoT Security Best Practices\n\n`;
        report += `1. Change default credentials\n`;
        report += `2. Disable unnecessary services\n`;
        report += `3. Use encryption for all communications\n`;
        report += `4. Keep firmware updated\n`;
        report += `5. Implement network segmentation\n`;
        report += `6. Use strong authentication\n`;
        report += `7. Monitor device activity\n`;
        report += `8. Disable remote access when not needed\n\n`;
        
        return report;
    }
}

async function main() {
    if (process.argv.length < 3) {
        console.log('Usage: node iot_device_scanner.js <target_ip>');
        console.log('Example: node iot_device_scanner.js 192.168.1.100');
        process.exit(1);
    }
    
    const targetIp = process.argv[2];
    
    const scanner = new IoTDeviceScanner(targetIp);
    await scanner.scanAll();
    
    const report = scanner.generateReport();
    
    const filename = `iot_device_scan_${targetIp.replace(/\./g, '_')}.md`;
    fs.writeFileSync(filename, report, 'utf8');
    
    console.log(`[+] IoT device scan complete`);
    console.log(`[+] Report saved to ${filename}`);
    console.log(`[!] WARNING: Only scan devices you own or have permission to test!`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = IoTDeviceScanner;

