/**
 * Firmware Analyzer
 * Analyzes IoT device firmware for security vulnerabilities.
 */

const fs = require('fs');
const path = require('path');
const AdmZip = require('adm-zip');
const tar = require('tar');

class FirmwareAnalyzer {
    constructor(firmwarePath) {
        this.firmwarePath = firmwarePath;
        this.findings = [];
        this.extractedPath = null;
    }

    async extractFirmware(extractPath = 'firmware_extracted') {
        console.log('[*] Extracting firmware...');

        try {
            if (fs.existsSync(extractPath)) {
                fs.rmSync(extractPath, { recursive: true, force: true });
            }
            fs.mkdirSync(extractPath, { recursive: true });

            if (this.firmwarePath.endsWith('.zip')) {
                const zip = new AdmZip(this.firmwarePath);
                zip.extractAllTo(extractPath, true);
            } else if (this.firmwarePath.endsWith('.tar') || this.firmwarePath.endsWith('.tar.gz') || this.firmwarePath.endsWith('.tgz')) {
                await tar.extract({
                    file: this.firmwarePath,
                    cwd: extractPath
                });
            } else {
                console.log('[-] Unsupported firmware format');
                return false;
            }

            this.extractedPath = extractPath;
            console.log(`[+] Firmware extracted to ${extractPath}`);
            return true;
        } catch (error) {
            console.log(`[-] Error extracting firmware: ${error.message}`);
            return false;
        }
    }

    findBinaries(extractPath = null) {
        if (!extractPath) {
            extractPath = this.extractedPath;
        }

        if (!extractPath) {
            return [];
        }

        console.log('[*] Searching for binary files...');

        const binaries = [];
        const walkDir = (dir) => {
            const files = fs.readdirSync(dir);
            for (const file of files) {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                if (stat.isDirectory()) {
                    walkDir(filePath);
                } else {
                    try {
                        const content = fs.readFileSync(filePath);
                        // Check if binary (contains null bytes or non-ASCII)
                        if (content.includes(0) || !content.toString('ascii', 0, Math.min(content.length, 512))) {
                            binaries.push(filePath);
                        }
                    } catch (error) {
                        // Continue
                    }
                }
            }
        };

        try {
            walkDir(extractPath);
        } catch (error) {
            // Continue
        }

        console.log(`[+] Found ${binaries.length} binary files`);
        return binaries;
    }

    checkDefaultCredentials(extractPath = null) {
        if (!extractPath) {
            extractPath = this.extractedPath;
        }

        if (!extractPath) {
            return [];
        }

        console.log('[*] Checking for default credentials...');

        const findings = [];
        const defaultCreds = [
            'admin:admin',
            'admin:password',
            'root:root',
            'root:12345',
            'user:user'
        ];

        const walkDir = (dir) => {
            const files = fs.readdirSync(dir);
            for (const file of files) {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                if (stat.isDirectory()) {
                    walkDir(filePath);
                } else if (file.endsWith('.txt') || file.endsWith('.conf') || file.endsWith('.cfg') || file.endsWith('.xml')) {
                    try {
                        const content = fs.readFileSync(filePath, 'utf8').toLowerCase();
                        for (const cred of defaultCreds) {
                            if (content.includes(cred)) {
                                findings.push({
                                    severity: 'Critical',
                                    issue: 'Default Credentials Found',
                                    description: `Found default credentials in ${file}`,
                                    file: filePath,
                                    credentials: cred
                                });
                            }
                        }
                    } catch (error) {
                        // Continue
                    }
                }
            }
        };

        try {
            walkDir(extractPath);
        } catch (error) {
            // Continue
        }

        this.findings.push(...findings);
        return findings;
    }

    async analyzeAll() {
        console.log(`[*] Analyzing firmware: ${this.firmwarePath}\n`);

        if (!fs.existsSync(this.firmwarePath)) {
            console.log(`[-] Firmware file not found: ${this.firmwarePath}`);
            return {};
        }

        const extractPath = 'firmware_extracted';
        if (!(await this.extractFirmware(extractPath))) {
            return {};
        }

        const binaries = this.findBinaries(extractPath);
        this.checkDefaultCredentials(extractPath);

        return {
            binaries: binaries,
            findings: this.findings
        };
    }

    generateReport() {
        let report = `# Firmware Security Analysis Report\n\n`;
        report += `**Firmware File**: ${path.basename(this.firmwarePath)}\n\n`;
        report += `## Summary\n\n`;
        report += `Total Findings: ${this.findings.length}\n\n`;

        const critical = this.findings.filter(f => f.severity === 'Critical');
        const high = this.findings.filter(f => f.severity === 'High');
        const medium = this.findings.filter(f => f.severity === 'Medium');
        const low = this.findings.filter(f => f.severity === 'Low');

        report += `- **Critical**: ${critical.length}\n`;
        report += `- **High**: ${high.length}\n`;
        report += `- **Medium**: ${medium.length}\n`;
        report += `- **Low**: ${low.length}\n\n`;

        report += `## Findings\n\n`;
        this.findings.forEach((finding, i) => {
            report += `### ${i + 1}. ${finding.issue}\n\n`;
            report += `**Severity**: ${finding.severity}\n\n`;
            report += `**Description**: ${finding.description}\n\n`;
            if (finding.file) {
                report += `**File**: ${finding.file}\n\n`;
            }
            report += `---\n\n`;
        });

        return report;
    }
}

async function main() {
    const args = process.argv.slice(2);
    if (args.length < 1) {
        console.log('Usage: node firmware_analyzer.js <firmware_file>');
        console.log('Example: node firmware_analyzer.js firmware.bin');
        console.log('\nNote: Requires adm-zip and tar packages');
        process.exit(1);
    }

    const firmwarePath = args[0];
    const analyzer = new FirmwareAnalyzer(firmwarePath);

    await analyzer.analyzeAll();

    const report = analyzer.generateReport();
    fs.writeFileSync('firmware_analysis_report.md', report, 'utf8');

    console.log(`\n[+] Analysis complete. Found ${analyzer.findings.length} security issues`);
    console.log(`[+] Report saved to firmware_analysis_report.md`);
    console.log(`[!] WARNING: Only analyze firmware you own or have permission to analyze!`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = FirmwareAnalyzer;

