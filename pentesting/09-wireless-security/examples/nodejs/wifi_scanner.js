/**
 * WiFi Scanner
 * Scans for wireless networks and analyzes WiFi security.
 * Note: Requires appropriate permissions and may need root/admin access.
 */

const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs');
const os = require('os');

const execAsync = promisify(exec);

class WiFiScanner {
    constructor() {
        this.networks = [];
        this.interface = null;
    }

    async getWiFiInterfaces() {
        const interfaces = [];
        
        try {
            if (os.platform() === 'win32') {
                const { stdout } = await execAsync('netsh wlan show interfaces');
                const lines = stdout.split('\n');
                for (const line of lines) {
                    if (line.includes('Name') && line.includes(':')) {
                        const interface = line.split(':')[1].trim();
                        interfaces.push(interface);
                    }
                }
            } else {
                try {
                    const { stdout } = await execAsync('iwconfig');
                    const lines = stdout.split('\n');
                    for (const line of lines) {
                        if (line.includes('IEEE 802.11')) {
                            const interface = line.split(' ')[0];
                            interfaces.push(interface);
                        }
                    }
                } catch (error) {
                    // Try ip command as fallback
                    const { stdout } = await execAsync('ip link show');
                    // Parse interfaces from ip output
                }
            }
        } catch (error) {
            console.log(`[-] Error getting interfaces: ${error.message}`);
        }
        
        return interfaces;
    }

    async scanNetworks(interface = null) {
        console.log('[*] Scanning for WiFi networks...');
        
        if (!interface) {
            const interfaces = await this.getWiFiInterfaces();
            if (interfaces.length > 0) {
                interface = interfaces[0];
            } else {
                console.log('[-] No WiFi interface found');
                return [];
            }
        }
        
        this.interface = interface;
        let networks = [];
        
        try {
            if (os.platform() === 'win32') {
                const { stdout } = await execAsync('netsh wlan show networks mode=Bssid');
                networks = this.parseWindowsScan(stdout);
            } else {
                try {
                    const { stdout } = await execAsync(`iwlist ${interface} scan`, { timeout: 30000 });
                    networks = this.parseLinuxScan(stdout);
                } catch (error) {
                    // Try nmcli as fallback
                    const { stdout } = await execAsync('nmcli -t -f SSID,SECURITY,SIGNAL device wifi list');
                    networks = this.parseNmcliScan(stdout);
                }
            }
        } catch (error) {
            console.log(`[-] Error scanning networks: ${error.message}`);
        }
        
        this.networks = networks;
        return networks;
    }

    parseWindowsScan(output) {
        const networks = [];
        let currentNetwork = {};
        
        const lines = output.split('\n');
        for (const line of lines) {
            const trimmed = line.trim();
            if (trimmed.includes('SSID') && trimmed.includes(':')) {
                if (Object.keys(currentNetwork).length > 0) {
                    networks.push(currentNetwork);
                }
                currentNetwork = { ssid: trimmed.split(':')[1].trim() };
            } else if (trimmed.includes('Authentication') && trimmed.includes(':')) {
                currentNetwork.auth = trimmed.split(':')[1].trim();
            } else if (trimmed.includes('Encryption') && trimmed.includes(':')) {
                currentNetwork.encryption = trimmed.split(':')[1].trim();
            } else if (trimmed.includes('Signal') && trimmed.includes(':')) {
                currentNetwork.signal = trimmed.split(':')[1].trim();
            }
        }
        
        if (Object.keys(currentNetwork).length > 0) {
            networks.push(currentNetwork);
        }
        
        return networks;
    }

    parseLinuxScan(output) {
        const networks = [];
        let currentNetwork = {};
        
        const lines = output.split('\n');
        for (const line of lines) {
            const trimmed = line.trim();
            if (trimmed.includes('ESSID:')) {
                if (Object.keys(currentNetwork).length > 0) {
                    networks.push(currentNetwork);
                }
                const ssid = trimmed.split('ESSID:')[1].trim().replace(/"/g, '');
                currentNetwork = { ssid: ssid };
            } else if (trimmed.includes('Encryption key:')) {
                currentNetwork.encrypted = trimmed.toLowerCase().includes('on');
            } else if (trimmed.includes('IE: IEEE 802.11i/WPA2')) {
                currentNetwork.security = 'WPA2';
            } else if (trimmed.includes('WPA')) {
                currentNetwork.security = 'WPA';
            }
        }
        
        if (Object.keys(currentNetwork).length > 0) {
            networks.push(currentNetwork);
        }
        
        return networks;
    }

    parseNmcliScan(output) {
        const networks = [];
        const lines = output.split('\n');
        for (const line of lines) {
            if (line.trim()) {
                const parts = line.split(':');
                if (parts.length >= 3) {
                    networks.push({
                        ssid: parts[0],
                        security: parts[1] || 'Open',
                        signal: parts[2] + '%'
                    });
                }
            }
        }
        return networks;
    }

    analyzeSecurity(network) {
        const analysis = {
            ssid: network.ssid || 'Unknown',
            security_level: 'Low',
            vulnerabilities: [],
            recommendations: []
        };
        
        const auth = (network.auth || network.security || 'Open').toLowerCase();
        
        if (auth.includes('wep')) {
            analysis.security_level = 'Critical';
            analysis.vulnerabilities.push('WEP encryption (easily crackable)');
            analysis.recommendations.push('Upgrade to WPA2 or WPA3');
        } else if (auth.includes('wpa') && !auth.includes('wpa2')) {
            analysis.security_level = 'High';
            analysis.vulnerabilities.push('WPA encryption (vulnerable to attacks)');
            analysis.recommendations.push('Upgrade to WPA2 or WPA3');
        } else if (auth.includes('wpa2')) {
            analysis.security_level = 'Medium';
            analysis.vulnerabilities.push('WPA2 (vulnerable to KRACK attacks)');
            analysis.recommendations.push('Consider WPA3 if supported');
        } else if (auth.includes('wpa3')) {
            analysis.security_level = 'Low';
            analysis.recommendations.push('WPA3 is secure');
        } else {
            analysis.security_level = 'Critical';
            analysis.vulnerabilities.push('Open network (no encryption)');
            analysis.recommendations.push('Enable WPA2 or WPA3 encryption');
        }
        
        return analysis;
    }

    generateReport() {
        let report = `# WiFi Security Scan Report\n\n`;
        report += `**Interface**: ${this.interface || 'N/A'}\n\n`;
        report += `## Networks Found (${this.networks.length})\n\n`;
        
        this.networks.forEach(network => {
            const analysis = this.analyzeSecurity(network);
            report += `### ${analysis.ssid}\n\n`;
            report += `- **Security Level**: ${analysis.security_level}\n`;
            report += `- **Authentication**: ${network.auth || network.security || 'Unknown'}\n`;
            report += `- **Signal**: ${network.signal || 'N/A'}\n`;
            
            if (analysis.vulnerabilities.length > 0) {
                report += `\n**Vulnerabilities**:\n`;
                analysis.vulnerabilities.forEach(vuln => {
                    report += `- ${vuln}\n`;
                });
            }
            
            if (analysis.recommendations.length > 0) {
                report += `\n**Recommendations**:\n`;
                analysis.recommendations.forEach(rec => {
                    report += `- ${rec}\n`;
                });
            }
            
            report += `\n`;
        });
        
        return report;
    }
}

async function main() {
    const scanner = new WiFiScanner();
    
    console.log('[*] WiFi Scanner\n');
    
    const interfaces = await scanner.getWiFiInterfaces();
    if (interfaces.length > 0) {
        console.log(`[+] Found ${interfaces.length} WiFi interface(s)`);
        interfaces.forEach(iface => {
            console.log(`    - ${iface}`);
        });
    } else {
        console.log('[-] No WiFi interfaces found');
        console.log('[!] Note: This tool may require root/admin privileges');
        process.exit(1);
    }
    
    const networks = await scanner.scanNetworks();
    
    if (networks.length > 0) {
        console.log(`\n[+] Found ${networks.length} networks`);
        networks.forEach(network => {
            console.log(`    - ${network.ssid || 'Unknown'}: ${network.auth || network.security || 'Open'}`);
        });
    } else {
        console.log('[-] No networks found or scan failed');
        console.log('[!] Try running with elevated privileges');
    }
    
    const report = scanner.generateReport();
    fs.writeFileSync('wifi_scan_report.md', report, 'utf8');
    
    console.log(`\n[+] Report saved to wifi_scan_report.md`);
    console.log(`[!] WARNING: Only scan networks you own or have permission to scan!`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = WiFiScanner;

