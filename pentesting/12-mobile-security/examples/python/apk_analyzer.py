#!/usr/bin/env python3
"""
APK Analyzer
Analyzes Android APK files for security vulnerabilities.
"""

import zipfile
import json
import sys
import os
from typing import Dict, List, Optional
import xml.etree.ElementTree as ET

class APKAnalyzer:
    def __init__(self, apk_path: str):
        self.apk_path = apk_path
        self.findings = []
        self.manifest_data = None
    
    def extract_apk(self, extract_path: str = 'apk_extracted') -> bool:
        """Extract APK file contents"""
        try:
            if os.path.exists(extract_path):
                import shutil
                shutil.rmtree(extract_path)
            
            os.makedirs(extract_path, exist_ok=True)
            
            with zipfile.ZipFile(self.apk_path, 'r') as zip_ref:
                zip_ref.extractall(extract_path)
            
            print(f"[+] APK extracted to {extract_path}")
            return True
        except Exception as e:
            print(f"[-] Error extracting APK: {e}")
            return False
    
    def analyze_manifest(self, extract_path: str = 'apk_extracted') -> Dict:
        """Analyze AndroidManifest.xml for security issues"""
        print("[*] Analyzing AndroidManifest.xml...")
        
        manifest_path = os.path.join(extract_path, 'AndroidManifest.xml')
        if not os.path.exists(manifest_path):
            print("[-] AndroidManifest.xml not found")
            return {}
        
        findings = {
            'permissions': [],
            'exported_components': [],
            'debuggable': False,
            'backup_allowed': False,
            'security_issues': []
        }
        
        try:
            # Parse manifest (binary XML, simplified parsing)
            with open(manifest_path, 'rb') as f:
                content = f.read()
            
            # Check for common security issues
            if b'android:debuggable="true"' in content:
                findings['debuggable'] = True
                findings['security_issues'].append('App is debuggable')
                self.findings.append({
                    'severity': 'High',
                    'issue': 'Debuggable Application',
                    'description': 'Application can be debugged, allowing code inspection'
                })
            
            if b'android:allowBackup="true"' in content:
                findings['backup_allowed'] = True
                findings['security_issues'].append('Backup allowed')
                self.findings.append({
                    'severity': 'Medium',
                    'issue': 'Backup Allowed',
                    'description': 'Application allows backup, potential data exposure'
                })
            
            # Extract permissions
            permission_pattern = b'android.permission.'
            start = 0
            while True:
                idx = content.find(permission_pattern, start)
                if idx == -1:
                    break
                end = content.find(b'"', idx)
                if end != -1:
                    perm = content[idx:end].decode('utf-8', errors='ignore')
                    findings['permissions'].append(perm)
                start = idx + 1
            
            # Check for dangerous permissions
            dangerous_perms = [
                'android.permission.READ_SMS',
                'android.permission.SEND_SMS',
                'android.permission.READ_PHONE_STATE',
                'android.permission.ACCESS_FINE_LOCATION',
                'android.permission.CAMERA',
                'android.permission.RECORD_AUDIO'
            ]
            
            for perm in findings['permissions']:
                if any(dangerous in perm for dangerous in dangerous_perms):
                    self.findings.append({
                        'severity': 'Medium',
                        'issue': f'Dangerous Permission: {perm}',
                        'description': 'Application requests sensitive permissions'
                    })
        
        except Exception as e:
            print(f"[-] Error analyzing manifest: {e}")
        
        self.manifest_data = findings
        return findings
    
    def check_certificate_pinning(self, extract_path: str = 'apk_extracted') -> bool:
        """Check for certificate pinning implementation"""
        print("[*] Checking for certificate pinning...")
        
        # Look for common pinning libraries
        pinning_indicators = [
            'CertificatePinner',
            'OkHttp',
            'TrustManager',
            'X509TrustManager'
        ]
        
        has_pinning = False
        for root, dirs, files in os.walk(extract_path):
            for file in files:
                if file.endswith(('.dex', '.so')):
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, 'rb') as f:
                            content = f.read()
                            for indicator in pinning_indicators:
                                if indicator.encode() in content:
                                    has_pinning = True
                                    break
                    except:
                        pass
        
        if not has_pinning:
            self.findings.append({
                'severity': 'Medium',
                'issue': 'No Certificate Pinning',
                'description': 'Application does not implement certificate pinning'
            })
        
        return has_pinning
    
    def check_insecure_storage(self, extract_path: str = 'apk_extracted') -> List[str]:
        """Check for insecure storage patterns"""
        print("[*] Checking for insecure storage...")
        
        insecure_patterns = [
            b'SharedPreferences',
            b'getSharedPreferences',
            b'SQLiteDatabase',
            b'openOrCreateDatabase'
        ]
        
        insecure_files = []
        for root, dirs, files in os.walk(extract_path):
            for file in files:
                if file.endswith('.smali') or file.endswith('.java'):
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, 'rb') as f:
                            content = f.read()
                            for pattern in insecure_patterns:
                                if pattern in content:
                                    insecure_files.append(file_path)
                                    break
                    except:
                        pass
        
        if insecure_files:
            self.findings.append({
                'severity': 'Medium',
                'issue': 'Potential Insecure Storage',
                'description': f'Found {len(insecure_files)} files with insecure storage patterns'
            })
        
        return insecure_files
    
    def analyze_all(self) -> Dict:
        """Perform complete APK analysis"""
        print(f"[*] Analyzing APK: {self.apk_path}\n")
        
        if not os.path.exists(self.apk_path):
            print(f"[-] APK file not found: {self.apk_path}")
            return {}
        
        # Extract APK
        extract_path = 'apk_extracted'
        if not self.extract_apk(extract_path):
            return {}
        
        # Analyze components
        self.analyze_manifest(extract_path)
        self.check_certificate_pinning(extract_path)
        self.check_insecure_storage(extract_path)
        
        return {
            'manifest': self.manifest_data,
            'findings': self.findings
        }
    
    def generate_report(self) -> str:
        """Generate APK analysis report"""
        report = f"# APK Security Analysis Report\n\n"
        report += f"**APK File**: {os.path.basename(self.apk_path)}\n\n"
        report += f"## Summary\n\n"
        report += f"Total Findings: {len(self.findings)}\n\n"
        
        # Group by severity
        critical = [f for f in self.findings if f['severity'] == 'Critical']
        high = [f for f in self.findings if f['severity'] == 'High']
        medium = [f for f in self.findings if f['severity'] == 'Medium']
        low = [f for f in self.findings if f['severity'] == 'Low']
        
        report += f"- **Critical**: {len(critical)}\n"
        report += f"- **High**: {len(high)}\n"
        report += f"- **Medium**: {len(medium)}\n"
        report += f"- **Low**: {len(low)}\n\n"
        
        report += "## Findings\n\n"
        for i, finding in enumerate(self.findings, 1):
            report += f"### {i}. {finding['issue']}\n\n"
            report += f"**Severity**: {finding['severity']}\n\n"
            report += f"**Description**: {finding['description']}\n\n"
            report += "---\n\n"
        
        return report

def main():
    if len(sys.argv) < 2:
        print("Usage: python apk_analyzer.py <apk_file>")
        print("Example: python apk_analyzer.py app.apk")
        sys.exit(1)
    
    apk_path = sys.argv[1]
    analyzer = APKAnalyzer(apk_path)
    
    results = analyzer.analyze_all()
    
    # Generate report
    report = analyzer.generate_report()
    with open('apk_analysis_report.md', 'w') as f:
        f.write(report)
    
    print(f"\n[+] Analysis complete. Found {len(analyzer.findings)} security issues")
    print(f"[+] Report saved to apk_analysis_report.md")
    print(f"[!] WARNING: Only analyze APKs you own or have permission to analyze!")

if __name__ == '__main__':
    main()

