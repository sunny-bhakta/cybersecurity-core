/**
 * APK Analyzer
 * Analyzes Android APK files for security vulnerabilities.
 */

const fs = require('fs');
const AdmZip = require('adm-zip');
const path = require('path');

class APKAnalyzer {
    constructor(apkPath) {
        this.apkPath = apkPath;
        this.findings = [];
        this.manifestData = null;
    }

    extractAPK(extractPath = 'apk_extracted') {
        try {
            if (fs.existsSync(extractPath)) {
                fs.rmSync(extractPath, { recursive: true, force: true });
            }
            fs.mkdirSync(extractPath, { recursive: true });

            const zip = new AdmZip(this.apkPath);
            zip.extractAllTo(extractPath, true);

            console.log(`[+] APK extracted to ${extractPath}`);
            return true;
        } catch (error) {
            console.log(`[-] Error extracting APK: ${error.message}`);
            return false;
        }
    }

    analyzeManifest(extractPath = 'apk_extracted') {
        console.log('[*] Analyzing AndroidManifest.xml...');

        const manifestPath = path.join(extractPath, 'AndroidManifest.xml');
        if (!fs.existsSync(manifestPath)) {
            console.log('[-] AndroidManifest.xml not found');
            return {};
        }

        const findings = {
            permissions: [],
            exported_components: [],
            debuggable: false,
            backup_allowed: false,
            security_issues: []
        };

        try {
            const content = fs.readFileSync(manifestPath);

            if (content.includes(Buffer.from('android:debuggable="true"'))) {
                findings.debuggable = true;
                findings.security_issues.push('App is debuggable');
                this.findings.push({
                    severity: 'High',
                    issue: 'Debuggable Application',
                    description: 'Application can be debugged, allowing code inspection'
                });
            }

            if (content.includes(Buffer.from('android:allowBackup="true"'))) {
                findings.backup_allowed = true;
                findings.security_issues.push('Backup allowed');
                this.findings.push({
                    severity: 'Medium',
                    issue: 'Backup Allowed',
                    description: 'Application allows backup, potential data exposure'
                });
            }

            // Extract permissions (simplified)
            const permissionRegex = /android\.permission\.[\w.]+/g;
            const contentStr = content.toString('utf-8', 0, Math.min(content.length, 10000));
            const matches = contentStr.match(permissionRegex);
            if (matches) {
                findings.permissions = [...new Set(matches)];
            }

            const dangerousPerms = [
                'android.permission.READ_SMS',
                'android.permission.SEND_SMS',
                'android.permission.READ_PHONE_STATE',
                'android.permission.ACCESS_FINE_LOCATION',
                'android.permission.CAMERA',
                'android.permission.RECORD_AUDIO'
            ];

            findings.permissions.forEach(perm => {
                if (dangerousPerms.some(dangerous => perm.includes(dangerous))) {
                    this.findings.push({
                        severity: 'Medium',
                        issue: `Dangerous Permission: ${perm}`,
                        description: 'Application requests sensitive permissions'
                    });
                }
            });
        } catch (error) {
            console.log(`[-] Error analyzing manifest: ${error.message}`);
        }

        this.manifestData = findings;
        return findings;
    }

    checkCertificatePinning(extractPath = 'apk_extracted') {
        console.log('[*] Checking for certificate pinning...');

        const pinningIndicators = [
            'CertificatePinner',
            'OkHttp',
            'TrustManager',
            'X509TrustManager'
        ];

        let hasPinning = false;
        const walkDir = (dir) => {
            const files = fs.readdirSync(dir);
            for (const file of files) {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                if (stat.isDirectory()) {
                    walkDir(filePath);
                } else if (file.endsWith('.dex') || file.endsWith('.so')) {
                    try {
                        const content = fs.readFileSync(filePath);
                        for (const indicator of pinningIndicators) {
                            if (content.includes(Buffer.from(indicator))) {
                                hasPinning = true;
                                break;
                            }
                        }
                    } catch (error) {
                        // Continue
                    }
                }
            }
        };

        try {
            walkDir(extractPath);
        } catch (error) {
            // Continue
        }

        if (!hasPinning) {
            this.findings.push({
                severity: 'Medium',
                issue: 'No Certificate Pinning',
                description: 'Application does not implement certificate pinning'
            });
        }

        return hasPinning;
    }

    analyzeAll() {
        console.log(`[*] Analyzing APK: ${this.apkPath}\n`);

        if (!fs.existsSync(this.apkPath)) {
            console.log(`[-] APK file not found: ${this.apkPath}`);
            return {};
        }

        const extractPath = 'apk_extracted';
        if (!this.extractAPK(extractPath)) {
            return {};
        }

        this.analyzeManifest(extractPath);
        this.checkCertificatePinning(extractPath);

        return {
            manifest: this.manifestData,
            findings: this.findings
        };
    }

    generateReport() {
        let report = `# APK Security Analysis Report\n\n`;
        report += `**APK File**: ${path.basename(this.apkPath)}\n\n`;
        report += `## Summary\n\n`;
        report += `Total Findings: ${this.findings.length}\n\n`;

        const critical = this.findings.filter(f => f.severity === 'Critical');
        const high = this.findings.filter(f => f.severity === 'High');
        const medium = this.findings.filter(f => f.severity === 'Medium');
        const low = this.findings.filter(f => f.severity === 'Low');

        report += `- **Critical**: ${critical.length}\n`;
        report += `- **High**: ${high.length}\n`;
        report += `- **Medium**: ${medium.length}\n`;
        report += `- **Low**: ${low.length}\n\n`;

        report += `## Findings\n\n`;
        this.findings.forEach((finding, i) => {
            report += `### ${i + 1}. ${finding.issue}\n\n`;
            report += `**Severity**: ${finding.severity}\n\n`;
            report += `**Description**: ${finding.description}\n\n`;
            report += `---\n\n`;
        });

        return report;
    }
}

function main() {
    const args = process.argv.slice(2);
    if (args.length < 1) {
        console.log('Usage: node apk_analyzer.js <apk_file>');
        console.log('Example: node apk_analyzer.js app.apk');
        console.log('\nNote: Requires adm-zip package: npm install adm-zip');
        process.exit(1);
    }

    const apkPath = args[0];
    const analyzer = new APKAnalyzer(apkPath);

    analyzer.analyzeAll();

    const report = analyzer.generateReport();
    fs.writeFileSync('apk_analysis_report.md', report, 'utf8');

    console.log(`\n[+] Analysis complete. Found ${analyzer.findings.length} security issues`);
    console.log(`[+] Report saved to apk_analysis_report.md`);
    console.log(`[!] WARNING: Only analyze APKs you own or have permission to analyze!`);
}

if (require.main === module) {
    main();
}

module.exports = APKAnalyzer;

