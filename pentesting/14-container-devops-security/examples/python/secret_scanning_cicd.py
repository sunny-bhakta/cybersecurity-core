#!/usr/bin/env python3
"""
Secret Scanning in CI/CD
Scans CI/CD pipelines and code for exposed secrets.
"""

import sys
import os
import re
from typing import List, Dict

class SecretScanningCICD:
    def __init__(self, target_path: str):
        self.target_path = target_path
        self.findings = []
        self.patterns = {
            'AWS_ACCESS_KEY': r'AKIA[0-9A-Z]{16}',
            'AWS_SECRET_KEY': r'aws_secret_access_key\s*=\s*["\']?([A-Za-z0-9/+=]{40})["\']?',
            'API_KEY': r'api[_-]?key\s*[:=]\s*["\']?([A-Za-z0-9]{20,})["\']?',
            'PRIVATE_KEY': r'-----BEGIN\s+(RSA\s+)?PRIVATE\s+KEY-----',
            'PASSWORD': r'password\s*[:=]\s*["\']?([^"\'\s]{8,})["\']?',
            'TOKEN': r'token\s*[:=]\s*["\']?([A-Za-z0-9]{20,})["\']?',
            'SECRET': r'secret\s*[:=]\s*["\']?([A-Za-z0-9]{20,})["\']?',
            'DATABASE_URL': r'(postgres|mysql|mongodb)://[^\s"\']+',
            'GITHUB_TOKEN': r'ghp_[A-Za-z0-9]{36}',
            'SLACK_TOKEN': r'xox[baprs]-[0-9a-zA-Z-]{10,}',
            'STRIPE_KEY': r'sk_live_[0-9a-zA-Z]{24,}',
            'DOCKER_PASSWORD': r'docker[_-]?password\s*[:=]\s*["\']?([A-Za-z0-9]{20,})["\']?',
            'KUBERNETES_SECRET': r'kind:\s*Secret',
        }
    
    def scan_file(self, file_path: str) -> List[Dict]:
        """Scan a single file for secrets"""
        findings = []
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                lines = content.split('\n')
                
                for line_num, line in enumerate(lines, 1):
                    for secret_type, pattern in self.patterns.items():
                        matches = re.finditer(pattern, line, re.IGNORECASE)
                        for match in matches:
                            secret_value = match.group(0)
                            if len(secret_value) > 20:
                                masked = secret_value[:10] + '...' + secret_value[-5:]
                            else:
                                masked = '***'
                            
                            findings.append({
                                'severity': 'High',
                                'type': secret_type,
                                'file': file_path,
                                'line': line_num,
                                'match': masked,
                                'description': f'Potential {secret_type} found in CI/CD pipeline'
                            })
        except Exception as e:
            print(f"[-] Error scanning {file_path}: {e}")
        
        return findings
    
    def scan_cicd_files(self, directory: str) -> List[Dict]:
        """Scan CI/CD specific files"""
        print(f"[*] Scanning CI/CD files in: {directory}...")
        
        findings = []
        cicd_files = []
        
        # GitHub Actions
        github_workflows = os.path.join(directory, '.github', 'workflows')
        if os.path.exists(github_workflows):
            for root, dirs, files in os.walk(github_workflows):
                for file in files:
                    if file.endswith(('.yml', '.yaml')):
                        cicd_files.append(os.path.join(root, file))
        
        # GitLab CI
        gitlab_ci = os.path.join(directory, '.gitlab-ci.yml')
        if os.path.exists(gitlab_ci):
            cicd_files.append(gitlab_ci)
        
        # Jenkins
        jenkinsfile = os.path.join(directory, 'Jenkinsfile')
        if os.path.exists(jenkinsfile):
            cicd_files.append(jenkinsfile)
        
        # CircleCI
        circleci_dir = os.path.join(directory, '.circleci')
        if os.path.exists(circleci_dir):
            config_file = os.path.join(circleci_dir, 'config.yml')
            if os.path.exists(config_file):
                cicd_files.append(config_file)
        
        # Azure DevOps
        azure_pipelines = os.path.join(directory, 'azure-pipelines.yml')
        if os.path.exists(azure_pipelines):
            cicd_files.append(azure_pipelines)
        
        # Scan all CI/CD files
        for cicd_file in cicd_files:
            file_findings = self.scan_file(cicd_file)
            findings.extend(file_findings)
        
        return findings
    
    def scan_directory(self, directory: str) -> List[Dict]:
        """Scan directory recursively for secrets"""
        print(f"[*] Scanning directory: {directory}...")
        
        findings = []
        excluded_dirs = {'.git', 'node_modules', '.venv', 'venv', '__pycache__', '.pytest_cache', 'dist', 'build'}
        excluded_extensions = {'.pyc', '.pyo', '.pyd', '.so', '.dll', '.exe', '.jpg', '.png', '.gif', '.pdf'}
        
        # First scan CI/CD specific files
        findings.extend(self.scan_cicd_files(directory))
        
        # Then scan all other files
        for root, dirs, files in os.walk(directory):
            # Exclude certain directories
            dirs[:] = [d for d in dirs if d not in excluded_dirs]
            
            for file in files:
                file_path = os.path.join(root, file)
                
                # Skip excluded file types
                if any(file.endswith(ext) for ext in excluded_extensions):
                    continue
                
                # Skip already scanned CI/CD files
                if any(cicd in file_path for cicd in ['.github/workflows', '.gitlab-ci.yml', 'Jenkinsfile', '.circleci', 'azure-pipelines.yml']):
                    continue
                
                file_findings = self.scan_file(file_path)
                findings.extend(file_findings)
        
        return findings
    
    def scan(self) -> Dict:
        """Perform secret scan"""
        if os.path.isfile(self.target_path):
            self.findings = self.scan_file(self.target_path)
        elif os.path.isdir(self.target_path):
            self.findings = self.scan_directory(self.target_path)
        else:
            print(f"[-] Path not found: {self.target_path}")
            return {}
        
        return {
            'findings': self.findings,
            'total_secrets': len(self.findings)
        }
    
    def generate_report(self) -> str:
        """Generate secret scan report"""
        report = f"# Secret Scanning in CI/CD Report\n\n"
        report += f"**Target**: {self.target_path}\n\n"
        
        if self.findings:
            report += f"## Summary\n\n"
            report += f"**Total Secrets Found**: {len(self.findings)}\n\n"
            
            # Group by type
            by_type = {}
            for finding in self.findings:
                secret_type = finding['type']
                if secret_type not in by_type:
                    by_type[secret_type] = []
                by_type[secret_type].append(finding)
            
            report += "## Findings by Type\n\n"
            for secret_type, findings in by_type.items():
                report += f"### {secret_type}: {len(findings)} found\n\n"
            
            # Group by file
            by_file = {}
            for finding in self.findings:
                file_path = finding['file']
                if file_path not in by_file:
                    by_file[file_path] = []
                by_file[file_path].append(finding)
            
            report += "## Findings by File\n\n"
            for file_path, findings in list(by_file.items())[:20]:  # Limit to 20 files
                report += f"### {file_path}\n\n"
                for finding in findings[:5]:  # Limit to 5 per file
                    report += f"- **Line {finding['line']}**: {finding['type']} - `{finding['match']}`\n"
                report += "\n"
            
            if len(by_file) > 20:
                report += f"\n*... and {len(by_file) - 20} more files*\n\n"
        else:
            report += "âœ… No secrets found.\n\n"
        
        report += "## Recommendations\n\n"
        report += "1. **Remove secrets immediately** from code and git history\n"
        report += "2. **Rotate all exposed credentials** immediately\n"
        report += "3. **Use CI/CD secrets management**:\n"
        report += "   - GitHub Secrets\n"
        report += "   - GitLab CI/CD Variables\n"
        report += "   - Jenkins Credentials\n"
        report += "   - Azure Key Vault\n"
        report += "4. **Add secrets to .gitignore**\n"
        report += "5. **Use pre-commit hooks** to prevent secret commits\n"
        report += "6. **Enable secret scanning** in CI/CD pipelines\n"
        report += "7. **Review git history** for exposed secrets\n"
        report += "8. **Use environment variables** instead of hardcoded values\n\n"
        
        return report

def main():
    if len(sys.argv) < 2:
        print("Usage: python secret_scanning_cicd.py <file_or_directory>")
        print("Example: python secret_scanning_cicd.py .github/workflows")
        print("Example: python secret_scanning_cicd.py /path/to/repo")
        sys.exit(1)
    
    target_path = sys.argv[1]
    
    scanner = SecretScanningCICD(target_path)
    scanner.scan()
    
    report = scanner.generate_report()
    
    filename = "secret_scanning_cicd_report.md"
    with open(filename, 'w') as f:
        f.write(report)
    
    print(f"[+] Secret scanning in CI/CD complete")
    print(f"[+] Report saved to {filename}")
    print(f"[!] Found {len(scanner.findings)} potential secrets")
    print("[!] WARNING: Review findings and rotate any exposed credentials immediately!")

if __name__ == "__main__":
    main()

