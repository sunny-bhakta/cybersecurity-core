#!/usr/bin/env node
/**
 * Container Image Vulnerability Scanner
 * Scans container images for known vulnerabilities.
 */

const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs');
const execAsync = promisify(exec);

class ContainerImageVulnerabilityScanner {
    constructor(imageName) {
        this.imageName = imageName;
        this.findings = [];
    }

    async scanWithTrivy() {
        console.log(`[*] Scanning image ${this.imageName} with Trivy...`);
        
        try {
            const { stdout, stderr } = await execAsync(
                `trivy image --format json ${this.imageName}`,
                { timeout: 300000 }
            );
            
            if (stdout) {
                const scanResults = JSON.parse(stdout);
                return this.parseTrivyResults(scanResults);
            }
        } catch (err) {
            if (err.message.includes('not found') || err.code === 'ENOENT') {
                console.log('[-] Trivy not found. Install from: https://github.com/aquasecurity/trivy');
            } else {
                console.log(`[-] Trivy scan failed: ${err.message}`);
            }
        }
        
        return {};
    }

    parseTrivyResults(results) {
        const findings = [];
        
        if (results.Results) {
            results.Results.forEach(result => {
                const target = result.Target || 'Unknown';
                const vulnerabilities = result.Vulnerabilities || [];
                
                vulnerabilities.forEach(vuln => {
                    findings.push({
                        severity: vuln.Severity || 'Unknown',
                        package: vuln.PkgName || 'Unknown',
                        vulnerabilityId: vuln.VulnerabilityID || 'Unknown',
                        title: vuln.Title || '',
                        description: vuln.Description || '',
                        target: target
                    });
                });
            });
        }
        
        this.findings = findings;
        return {
            findings,
            totalVulnerabilities: findings.length
        };
    }

    async scanWithDockerScan() {
        console.log(`[*] Scanning image ${this.imageName} with Docker scan...`);
        
        try {
            const { stdout, stderr } = await execAsync(
                `docker scan --json ${this.imageName}`,
                { timeout: 300000 }
            );
            
            if (stdout) {
                const scanResults = JSON.parse(stdout);
                return this.parseDockerScanResults(scanResults);
            }
        } catch (err) {
            console.log(`[-] Docker scan failed: ${err.message}`);
        }
        
        return {};
    }

    parseDockerScanResults(results) {
        const findings = [];
        
        const vulnerabilities = results.vulnerabilities || [];
        
        vulnerabilities.forEach(vuln => {
            findings.push({
                severity: vuln.severity || 'Unknown',
                package: vuln.package || 'Unknown',
                vulnerabilityId: vuln.id || 'Unknown',
                title: vuln.title || '',
                description: vuln.description || '',
                target: this.imageName
            });
        });
        
        this.findings = findings;
        return {
            findings,
            totalVulnerabilities: findings.length
        };
    }

    async scan(tool = 'trivy') {
        if (tool === 'trivy') {
            return await this.scanWithTrivy();
        } else if (tool === 'docker') {
            return await this.scanWithDockerScan();
        } else {
            console.log(`[-] Unknown tool: ${tool}`);
            return {};
        }
    }

    generateReport() {
        let report = `# Container Image Vulnerability Scan Report\n\n`;
        report += `**Image**: ${this.imageName}\n\n`;
        
        if (this.findings.length > 0) {
            report += `## Summary\n\n`;
            report += `Total Vulnerabilities: ${this.findings.length}\n\n`;
            
            const critical = this.findings.filter(f => f.severity === 'CRITICAL');
            const high = this.findings.filter(f => f.severity === 'HIGH');
            const medium = this.findings.filter(f => f.severity === 'MEDIUM');
            const low = this.findings.filter(f => f.severity === 'LOW');
            
            report += `- **Critical**: ${critical.length}\n`;
            report += `- **High**: ${high.length}\n`;
            report += `- **Medium**: ${medium.length}\n`;
            report += `- **Low**: ${low.length}\n\n`;
            
            const severities = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'];
            severities.forEach(severity => {
                const severityFindings = this.findings.filter(f => f.severity === severity);
                if (severityFindings.length > 0) {
                    report += `## ${severity} Vulnerabilities (${severityFindings.length})\n\n`;
                    severityFindings.slice(0, 20).forEach((finding, i) => {
                        report += `### ${i + 1}. ${finding.vulnerabilityId}\n\n`;
                        report += `**Package**: ${finding.package}\n\n`;
                        report += `**Title**: ${finding.title}\n\n`;
                        if (finding.description) {
                            report += `**Description**: ${finding.description.substring(0, 200)}...\n\n`;
                        }
                        report += `---\n\n`;
                    });
                    
                    if (severityFindings.length > 20) {
                        report += `*... and ${severityFindings.length - 20} more ${severity} vulnerabilities*\n\n`;
                    }
                }
            });
        } else {
            report += `âœ… No vulnerabilities found.\n\n`;
        }
        
        report += `## Recommendations\n\n`;
        report += `1. Update base images regularly\n`;
        report += `2. Use minimal base images (Alpine, Distroless)\n`;
        report += `3. Keep packages up to date\n`;
        report += `4. Scan images before deployment\n`;
        report += `5. Use image signing and verification\n`;
        report += `6. Implement image scanning in CI/CD\n`;
        report += `7. Monitor for new vulnerabilities\n\n`;
        
        return report;
    }
}

async function main() {
    if (process.argv.length < 3) {
        console.log('Usage: node container_image_vulnerability_scanner.js <image_name> [tool]');
        console.log('Example: node container_image_vulnerability_scanner.js nginx:latest');
        console.log('Example: node container_image_vulnerability_scanner.js nginx:latest trivy');
        console.log('\nTools: trivy (default), docker');
        process.exit(1);
    }
    
    const imageName = process.argv[2];
    const tool = process.argv[3] || 'trivy';
    
    const scanner = new ContainerImageVulnerabilityScanner(imageName);
    await scanner.scan(tool);
    
    const report = scanner.generateReport();
    
    const filename = `container_vulnerability_scan_${imageName.replace(/:/g, '_').replace(/\//g, '_')}.md`;
    fs.writeFileSync(filename, report, 'utf8');
    
    console.log(`[+] Container image vulnerability scan complete`);
    console.log(`[+] Report saved to ${filename}`);
    console.log(`[!] Found ${scanner.findings.length} vulnerabilities`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = ContainerImageVulnerabilityScanner;

