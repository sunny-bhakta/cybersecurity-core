#!/usr/bin/env node
/**
 * IaC Security Scanner
 * Scans Infrastructure as Code (IaC) files for security misconfigurations.
 */

const fs = require('fs');
const path = require('path');

class IaCSecurityScanner {
    constructor(targetPath) {
        this.targetPath = targetPath;
        this.findings = [];
    }

    scanTerraform(tfFile) {
        console.log(`[*] Scanning Terraform file: ${tfFile}...`);
        
        const findings = [];
        
        try {
            const content = fs.readFileSync(tfFile, 'utf8');
            
            if (content.toLowerCase().includes('password') || content.toLowerCase().includes('secret')) {
                findings.push({
                    severity: 'High',
                    issue: 'Potential Hardcoded Secrets',
                    description: 'Terraform file may contain hardcoded secrets',
                    file: tfFile
                });
            }
            
            if (content.toLowerCase().includes('public_access') || content.toLowerCase().includes('publicly_accessible')) {
                if (content.toLowerCase().includes('true')) {
                    findings.push({
                        severity: 'High',
                        issue: 'Public Access Enabled',
                        description: 'Resource may be publicly accessible',
                        file: tfFile
                    });
                }
            }
            
            if (content.includes('0.0.0.0/0') || content.includes('::/0')) {
                findings.push({
                    severity: 'Critical',
                    issue: 'Open Security Group',
                    description: 'Security group allows access from anywhere (0.0.0.0/0)',
                    file: tfFile
                });
            }
        } catch (err) {
            console.log(`[-] Error scanning ${tfFile}: ${err.message}`);
        }
        
        return findings;
    }

    scanCloudFormation(cfFile) {
        console.log(`[*] Scanning CloudFormation template: ${cfFile}...`);
        
        const findings = [];
        
        try {
            const content = fs.readFileSync(cfFile, 'utf8');
            let template;
            
            if (cfFile.endsWith('.json')) {
                template = JSON.parse(content);
            } else {
                const yaml = require('js-yaml');
                template = yaml.load(content);
            }
            
            const resources = template.Resources || {};
            
            Object.entries(resources).forEach(([resourceName, resource]) => {
                const resourceType = resource.Type || '';
                const properties = resource.Properties || {};
                
                if (resourceType.includes('S3::Bucket')) {
                    if (!properties.PublicAccessBlockConfiguration) {
                        findings.push({
                            severity: 'High',
                            issue: `S3 Bucket Without Public Access Block: ${resourceName}`,
                            description: 'S3 bucket may be publicly accessible',
                            file: cfFile
                        });
                    }
                }
                
                if (resourceType.includes('EC2::SecurityGroup')) {
                    const ingressRules = properties.SecurityGroupIngress || [];
                    ingressRules.forEach(rule => {
                        if (rule.CidrIp === '0.0.0.0/0') {
                            findings.push({
                                severity: 'Critical',
                                issue: `Open Security Group Rule: ${resourceName}`,
                                description: 'Security group allows access from anywhere',
                                file: cfFile
                            });
                        }
                    });
                }
            });
        } catch (err) {
            console.log(`[-] Error scanning ${cfFile}: ${err.message}`);
        }
        
        return findings;
    }

    scanKubernetes(k8sFile) {
        console.log(`[*] Scanning Kubernetes manifest: ${k8sFile}...`);
        
        const findings = [];
        
        try {
            const content = fs.readFileSync(k8sFile, 'utf8');
            let manifest;
            
            if (k8sFile.endsWith('.json')) {
                manifest = JSON.parse(content);
            } else {
                const yaml = require('js-yaml');
                manifest = yaml.load(content);
            }
            
            if (manifest.kind === 'ServiceAccount') {
                if (manifest.metadata?.name === 'default') {
                    findings.push({
                        severity: 'Medium',
                        issue: 'Default Service Account',
                        description: 'Using default service account',
                        file: k8sFile
                    });
                }
            }
            
            if (['Pod', 'Deployment', 'StatefulSet'].includes(manifest.kind)) {
                const containers = manifest.spec?.containers || [];
                containers.forEach(container => {
                    if (container.securityContext?.privileged === true) {
                        findings.push({
                            severity: 'High',
                            issue: 'Privileged Container',
                            description: `Container ${container.name} runs in privileged mode`,
                            file: k8sFile
                        });
                    }
                });
                
                if (manifest.spec?.hostNetwork === true) {
                    findings.push({
                        severity: 'High',
                        issue: 'Host Network Access',
                        description: 'Pod uses host network',
                        file: k8sFile
                    });
                }
            }
        } catch (err) {
            console.log(`[-] Error scanning ${k8sFile}: ${err.message}`);
        }
        
        return findings;
    }

    scanDirectory(directory) {
        console.log(`[*] Scanning directory: ${directory}...`);
        
        const findings = [];
        
        function walkDir(dir) {
            const files = fs.readdirSync(dir);
            
            files.forEach(file => {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                
                if (stat.isDirectory()) {
                    if (!['.git', 'node_modules', '.terraform'].includes(file)) {
                        walkDir(filePath);
                    }
                } else {
                    if (file.endsWith('.tf') || file.endsWith('.tfvars')) {
                        findings.push(...this.scanTerraform(filePath));
                    } else if (file.endsWith('.yaml') || file.endsWith('.yml')) {
                        if (file.toLowerCase().includes('cloudformation') || file.toLowerCase().includes('cf')) {
                            findings.push(...this.scanCloudFormation(filePath));
                        } else if (file.toLowerCase().includes('k8s') || file.toLowerCase().includes('kubernetes')) {
                            findings.push(...this.scanKubernetes(filePath));
                        }
                    } else if (file.endsWith('.json')) {
                        if (file.toLowerCase().includes('cloudformation') || file.toLowerCase().includes('cf')) {
                            findings.push(...this.scanCloudFormation(filePath));
                        }
                    }
                }
            });
        }
        
        walkDir.call(this, directory);
        return findings;
    }

    scan() {
        const stat = fs.statSync(this.targetPath);
        
        if (stat.isFile()) {
            if (this.targetPath.endsWith('.tf')) {
                this.findings = this.scanTerraform(this.targetPath);
            } else if (this.targetPath.toLowerCase().includes('cloudformation')) {
                this.findings = this.scanCloudFormation(this.targetPath);
            } else if (this.targetPath.toLowerCase().includes('k8s') || this.targetPath.toLowerCase().includes('kubernetes')) {
                this.findings = this.scanKubernetes(this.targetPath);
            }
        } else if (stat.isDirectory()) {
            this.findings = this.scanDirectory(this.targetPath);
        } else {
            console.log(`[-] Path not found: ${this.targetPath}`);
            return {};
        }
        
        return {
            findings: this.findings
        };
    }

    generateReport() {
        let report = `# IaC Security Scan Report\n\n`;
        report += `**Target**: ${this.targetPath}\n\n`;
        
        if (this.findings.length > 0) {
            report += `## Summary\n\n`;
            report += `Total Findings: ${this.findings.length}\n\n`;
            
            const critical = this.findings.filter(f => f.severity === 'Critical');
            const high = this.findings.filter(f => f.severity === 'High');
            const medium = this.findings.filter(f => f.severity === 'Medium');
            
            report += `- **Critical**: ${critical.length}\n`;
            report += `- **High**: ${high.length}\n`;
            report += `- **Medium**: ${medium.length}\n\n`;
            
            report += `## Findings\n\n`;
            this.findings.forEach((finding, i) => {
                report += `### ${i + 1}. ${finding.issue}\n\n`;
                report += `**Severity**: ${finding.severity}\n\n`;
                report += `**Description**: ${finding.description}\n\n`;
                report += `**File**: \`${finding.file}\`\n\n`;
                report += `---\n\n`;
            });
        } else {
            report += `âœ… No security issues found.\n\n`;
        }
        
        report += `## Best Practices\n\n`;
        report += `1. Use secrets management (AWS Secrets Manager, HashiCorp Vault)\n`;
        report += `2. Implement least privilege access\n`;
        report += `3. Enable encryption at rest and in transit\n`;
        report += `4. Restrict network access (security groups, firewalls)\n`;
        report += `5. Use private subnets for sensitive resources\n`;
        report += `6. Enable logging and monitoring\n`;
        report += `7. Review and validate IaC before deployment\n`;
        report += `8. Use static analysis tools (Checkov, Terrascan, tfsec)\n\n`;
        
        return report;
    }
}

function main() {
    if (process.argv.length < 3) {
        console.log('Usage: node iac_security_scanner.js <file_or_directory>');
        console.log('Example: node iac_security_scanner.js terraform/');
        console.log('Example: node iac_security_scanner.js template.yaml');
        process.exit(1);
    }
    
    const targetPath = process.argv[2];
    
    const scanner = new IaCSecurityScanner(targetPath);
    scanner.scan();
    
    const report = scanner.generateReport();
    
    const filename = 'iac_security_scan.md';
    fs.writeFileSync(filename, report, 'utf8');
    
    console.log(`[+] IaC security scan complete`);
    console.log(`[+] Report saved to ${filename}`);
}

if (require.main === module) {
    try {
        require('js-yaml');
    } catch (err) {
        console.log('[!] Note: Install js-yaml for YAML parsing: npm install js-yaml');
    }
    main();
}

module.exports = IaCSecurityScanner;

