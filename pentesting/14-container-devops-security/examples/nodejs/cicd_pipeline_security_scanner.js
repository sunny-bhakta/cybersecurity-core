#!/usr/bin/env node
/**
 * CI/CD Pipeline Security Scanner
 * Scans CI/CD pipeline configurations for security vulnerabilities.
 */

const fs = require('fs');
const path = require('path');

class CICDPipelineSecurityScanner {
    constructor(pipelinePath) {
        this.pipelinePath = pipelinePath;
        this.findings = [];
    }

    scanGitHubActions(workflowFile) {
        console.log(`[*] Scanning GitHub Actions workflow: ${workflowFile}...`);
        
        const findings = [];
        
        try {
            const content = fs.readFileSync(workflowFile, 'utf8');
            const workflow = require('js-yaml').load(content);
            
            // Check for hardcoded secrets
            if (content.includes('password') || content.includes('secret') || content.includes('token')) {
                findings.push({
                    severity: 'High',
                    issue: 'Potential Hardcoded Secrets',
                    description: 'Workflow may contain hardcoded secrets',
                    file: workflowFile
                });
            }
            
            // Check for unsafe permissions
            if (workflow.permissions) {
                if (workflow.permissions === 'write-all' || workflow.permissions === '*') {
                    findings.push({
                        severity: 'High',
                        issue: 'Overly Permissive Workflow',
                        description: 'Workflow has overly permissive permissions',
                        file: workflowFile
                    });
                }
            }
            
            // Check jobs
            if (workflow.jobs) {
                Object.entries(workflow.jobs).forEach(([jobName, job]) => {
                    if (job.steps) {
                        job.steps.forEach((step, i) => {
                            // Check for script injection
                            if (step.run && step.run.includes('${{')) {
                                findings.push({
                                    severity: 'Medium',
                                    issue: 'Potential Script Injection',
                                    description: `Step ${i + 1} in job ${jobName} may be vulnerable to injection`,
                                    file: workflowFile
                                });
                            }
                        });
                    }
                });
            }
        } catch (err) {
            console.log(`[-] Error scanning ${workflowFile}: ${err.message}`);
        }
        
        return findings;
    }

    scanGitLabCI(configFile) {
        console.log(`[*] Scanning GitLab CI config: ${configFile}...`);
        
        const findings = [];
        
        try {
            const content = fs.readFileSync(configFile, 'utf8');
            const config = require('js-yaml').load(content);
            
            // Check for hardcoded secrets
            if (content.includes('password') || content.includes('secret') || content.includes('token')) {
                findings.push({
                    severity: 'High',
                    issue: 'Potential Hardcoded Secrets',
                    description: 'GitLab CI config may contain hardcoded secrets',
                    file: configFile
                });
            }
            
            // Check for unsafe variables
            if (config.variables) {
                Object.entries(config.variables).forEach(([key, value]) => {
                    if (typeof value === 'string' && (value.includes('password') || value.includes('secret'))) {
                        findings.push({
                            severity: 'Medium',
                            issue: 'Unsafe Variable',
                            description: `Variable ${key} may contain sensitive data`,
                            file: configFile
                        });
                    }
                });
            }
        } catch (err) {
            console.log(`[-] Error scanning ${configFile}: ${err.message}`);
        }
        
        return findings;
    }

    scanJenkinsfile(jenkinsfile) {
        console.log(`[*] Scanning Jenkinsfile: ${jenkinsfile}...`);
        
        const findings = [];
        
        try {
            const content = fs.readFileSync(jenkinsfile, 'utf8');
            
            // Check for hardcoded credentials
            if (content.includes('withCredentials') && content.includes('password')) {
                // Check if credentials are properly managed
                if (!content.includes('credentials(')) {
                    findings.push({
                        severity: 'High',
                        issue: 'Hardcoded Credentials',
                        description: 'Jenkinsfile may contain hardcoded credentials',
                        file: jenkinsfile
                    });
                }
            }
            
            // Check for script security
            if (content.includes('sh(') || content.includes('bat(')) {
                const scriptMatches = content.match(/(sh|bat)\(['"]([^'"]+)['"]\)/g);
                if (scriptMatches) {
                    scriptMatches.forEach(match => {
                        if (match.includes('${') || match.includes('$env')) {
                            findings.push({
                                severity: 'Medium',
                                issue: 'Potential Script Injection',
                                description: 'Script may be vulnerable to injection',
                                file: jenkinsfile
                            });
                        }
                    });
                }
            }
        } catch (err) {
            console.log(`[-] Error scanning ${jenkinsfile}: ${err.message}`);
        }
        
        return findings;
    }

    scanDirectory(directory) {
        console.log(`[*] Scanning directory: ${directory}...`);
        
        const findings = [];
        
        // Scan for GitHub Actions
        const githubActionsPath = path.join(directory, '.github', 'workflows');
        if (fs.existsSync(githubActionsPath)) {
            const files = fs.readdirSync(githubActionsPath);
            files.forEach(file => {
                if (file.endsWith('.yml') || file.endsWith('.yaml')) {
                    findings.push(...this.scanGitHubActions(path.join(githubActionsPath, file)));
                }
            });
        }
        
        // Scan for GitLab CI
        const gitlabCIPath = path.join(directory, '.gitlab-ci.yml');
        if (fs.existsSync(gitlabCIPath)) {
            findings.push(...this.scanGitLabCI(gitlabCIPath));
        }
        
        // Scan for Jenkinsfile
        const jenkinsfilePath = path.join(directory, 'Jenkinsfile');
        if (fs.existsSync(jenkinsfilePath)) {
            findings.push(...this.scanJenkinsfile(jenkinsfilePath));
        }
        
        return findings;
    }

    scan() {
        const stat = fs.statSync(this.pipelinePath);
        
        if (stat.isFile()) {
            if (this.pipelinePath.includes('.github/workflows')) {
                this.findings = this.scanGitHubActions(this.pipelinePath);
            } else if (this.pipelinePath.includes('.gitlab-ci.yml')) {
                this.findings = this.scanGitLabCI(this.pipelinePath);
            } else if (this.pipelinePath.includes('Jenkinsfile')) {
                this.findings = this.scanJenkinsfile(this.pipelinePath);
            }
        } else if (stat.isDirectory()) {
            this.findings = this.scanDirectory(this.pipelinePath);
        }
        
        return {
            findings: this.findings
        };
    }

    generateReport() {
        let report = `# CI/CD Pipeline Security Scan Report\n\n`;
        report += `**Target**: ${this.pipelinePath}\n\n`;
        
        if (this.findings.length > 0) {
            report += `## Summary\n\n`;
            report += `Total Findings: ${this.findings.length}\n\n`;
            
            const critical = this.findings.filter(f => f.severity === 'Critical');
            const high = this.findings.filter(f => f.severity === 'High');
            const medium = this.findings.filter(f => f.severity === 'Medium');
            
            report += `- **Critical**: ${critical.length}\n`;
            report += `- **High**: ${high.length}\n`;
            report += `- **Medium**: ${medium.length}\n\n`;
            
            report += `## Findings\n\n`;
            this.findings.forEach((finding, i) => {
                report += `### ${i + 1}. ${finding.issue}\n\n`;
                report += `**Severity**: ${finding.severity}\n\n`;
                report += `**Description**: ${finding.description}\n\n`;
                report += `**File**: \`${finding.file}\`\n\n`;
                report += `---\n\n`;
            });
        } else {
            report += `âœ… No security issues found.\n\n`;
        }
        
        report += `## Best Practices\n\n`;
        report += `1. Use secrets management (GitHub Secrets, GitLab Variables, Jenkins Credentials)\n`;
        report += `2. Implement least privilege permissions\n`;
        report += `3. Validate and sanitize inputs\n`;
        report += `4. Use pinned versions for actions and images\n`;
        report += `5. Enable branch protection\n`;
        report += `6. Review pipeline changes before merging\n`;
        report += `7. Use separate environments for testing and production\n\n`;
        
        return report;
    }
}

function main() {
    if (process.argv.length < 3) {
        console.log('Usage: node cicd_pipeline_security_scanner.js <pipeline_file_or_directory>');
        console.log('Example: node cicd_pipeline_security_scanner.js .github/workflows');
        console.log('Example: node cicd_pipeline_security_scanner.js .gitlab-ci.yml');
        process.exit(1);
    }
    
    const pipelinePath = process.argv[2];
    
    const scanner = new CICDPipelineSecurityScanner(pipelinePath);
    scanner.scan();
    
    const report = scanner.generateReport();
    
    const filename = 'cicd_pipeline_security_scan.md';
    fs.writeFileSync(filename, report, 'utf8');
    
    console.log(`[+] CI/CD pipeline security scan complete`);
    console.log(`[+] Report saved to ${filename}`);
}

if (require.main === module) {
    try {
        require('js-yaml');
    } catch (err) {
        console.log('[!] Note: Install js-yaml for YAML parsing: npm install js-yaml');
    }
    main();
}

module.exports = CICDPipelineSecurityScanner;

