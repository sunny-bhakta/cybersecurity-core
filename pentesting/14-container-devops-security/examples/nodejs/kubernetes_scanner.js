/**
 * Kubernetes Security Scanner
 * Scans Kubernetes clusters for security misconfigurations.
 */

const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs');

const execAsync = promisify(exec);

class KubernetesScanner {
    constructor() {
        this.findings = [];
        this.namespaces = [];
    }

    async checkKubectl() {
        try {
            await execAsync('kubectl version --client', { timeout: 5000 });
            return true;
        } catch {
            return false;
        }
    }

    async scanNamespaces() {
        console.log('[*] Scanning namespaces...');

        try {
            const { stdout } = await execAsync('kubectl get namespaces -o json', { timeout: 30000 });
            const data = JSON.parse(stdout);
            const namespaces = data.items.map(ns => ns.metadata.name);
            this.namespaces = namespaces;
            return namespaces;
        } catch (error) {
            console.log(`[-] Error scanning namespaces: ${error.message}`);
            return [];
        }
    }

    async checkRBAC(namespace = 'default') {
        console.log(`[*] Checking RBAC in namespace: ${namespace}...`);

        const findings = [];

        try {
            const { stdout } = await execAsync(`kubectl get roles -n ${namespace} -o json`, { timeout: 30000 });
            const data = JSON.parse(stdout);

            for (const role of data.items || []) {
                const rules = role.rules || [];
                for (const rule of rules) {
                    if (rule.verbs && rule.verbs.includes('*') || rule.resources && rule.resources.includes('*')) {
                        findings.push({
                            severity: 'High',
                            issue: `Overly Permissive Role: ${role.metadata.name}`,
                            description: 'Role has wildcard permissions',
                            namespace: namespace
                        });
                    }
                }
            }
        } catch (error) {
            console.log(`[-] Error checking RBAC: ${error.message}`);
        }

        this.findings.push(...findings);
        return findings;
    }

    async checkSecrets(namespace = 'default') {
        console.log(`[*] Checking secrets in namespace: ${namespace}...`);

        const findings = [];

        try {
            const { stdout } = await execAsync(`kubectl get secrets -n ${namespace} -o json`, { timeout: 30000 });
            const data = JSON.parse(stdout);

            for (const secret of data.items || []) {
                if (secret.type === 'Opaque') {
                    findings.push({
                        severity: 'Medium',
                        issue: `Secret Found: ${secret.metadata.name}`,
                        description: 'Opaque secret in cluster',
                        namespace: namespace
                    });
                }
            }
        } catch (error) {
            console.log(`[-] Error checking secrets: ${error.message}`);
        }

        this.findings.push(...findings);
        return findings;
    }

    async checkPodSecurity(namespace = 'default') {
        console.log(`[*] Checking pod security in namespace: ${namespace}...`);

        const findings = [];

        try {
            const { stdout } = await execAsync(`kubectl get pods -n ${namespace} -o json`, { timeout: 30000 });
            const data = JSON.parse(stdout);

            for (const pod of data.items || []) {
                const spec = pod.spec || {};
                const securityContext = spec.securityContext || {};

                if (securityContext.runAsUser === 0 || securityContext.runAsUser === undefined) {
                    findings.push({
                        severity: 'High',
                        issue: `Pod Running as Root: ${pod.metadata.name}`,
                        description: 'Pod is running as root user',
                        namespace: namespace
                    });
                }

                const containers = spec.containers || [];
                for (const container of containers) {
                    const containerSecurity = container.securityContext || {};
                    if (containerSecurity.privileged) {
                        findings.push({
                            severity: 'Critical',
                            issue: `Privileged Container: ${container.name}`,
                            description: 'Container is running in privileged mode',
                            namespace: namespace
                        });
                    }
                }
            }
        } catch (error) {
            console.log(`[-] Error checking pod security: ${error.message}`);
        }

        this.findings.push(...findings);
        return findings;
    }

    async scanAll() {
        console.log('[*] Starting Kubernetes security scan...\n');

        if (!(await this.checkKubectl())) {
            console.log('[-] kubectl not found. Install kubectl to use this tool.');
            return {};
        }

        const namespaces = await this.scanNamespaces();
        const namespacesToScan = namespaces.length > 0 ? namespaces : ['default'];

        for (const namespace of namespacesToScan) {
            console.log(`\n[*] Scanning namespace: ${namespace}`);
            await this.checkRBAC(namespace);
            await this.checkSecrets(namespace);
            await this.checkPodSecurity(namespace);
        }

        return {
            namespaces_scanned: namespacesToScan.length,
            findings: this.findings
        };
    }

    generateReport() {
        let report = `# Kubernetes Security Scan Report\n\n`;
        report += `## Summary\n\n`;
        report += `Namespaces Scanned: ${this.namespaces.length}\n`;
        report += `Total Findings: ${this.findings.length}\n\n`;

        const critical = this.findings.filter(f => f.severity === 'Critical');
        const high = this.findings.filter(f => f.severity === 'High');
        const medium = this.findings.filter(f => f.severity === 'Medium');
        const low = this.findings.filter(f => f.severity === 'Low');

        report += `- **Critical**: ${critical.length}\n`;
        report += `- **High**: ${high.length}\n`;
        report += `- **Medium**: ${medium.length}\n`;
        report += `- **Low**: ${low.length}\n\n`;

        report += `## Findings\n\n`;
        this.findings.forEach((finding, i) => {
            report += `### ${i + 1}. ${finding.issue}\n\n`;
            report += `**Severity**: ${finding.severity}\n\n`;
            report += `**Namespace**: ${finding.namespace || 'N/A'}\n\n`;
            report += `**Description**: ${finding.description}\n\n`;
            report += `---\n\n`;
        });

        return report;
    }
}

async function main() {
    const args = process.argv.slice(2);
    const scanner = new KubernetesScanner();

    if (args.length > 0) {
        const namespace = args[0];
        console.log(`[*] Scanning namespace: ${namespace}`);
        await scanner.checkRBAC(namespace);
        await scanner.checkSecrets(namespace);
        await scanner.checkPodSecurity(namespace);
    } else {
        await scanner.scanAll();
    }

    const report = scanner.generateReport();
    fs.writeFileSync('kubernetes_security_report.md', report, 'utf8');

    console.log(`\n[+] Scan complete. Found ${scanner.findings.length} security issues`);
    console.log(`[+] Report saved to kubernetes_security_report.md`);
    console.log(`[!] WARNING: Only scan clusters you own or have permission to scan!`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = KubernetesScanner;

