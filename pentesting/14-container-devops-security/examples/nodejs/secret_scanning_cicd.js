#!/usr/bin/env node
/**
 * Secret Scanning in CI/CD
 * Scans CI/CD pipelines and code for exposed secrets.
 */

const fs = require('fs');
const path = require('path');

class SecretScanningCICD {
    constructor(targetPath) {
        this.targetPath = targetPath;
        this.findings = [];
        this.patterns = {
            AWS_ACCESS_KEY: /AKIA[0-9A-Z]{16}/,
            AWS_SECRET_KEY: /aws_secret_access_key\s*=\s*["']?([A-Za-z0-9/+=]{40})["']?/i,
            API_KEY: /api[_-]?key\s*[:=]\s*["']?([A-Za-z0-9]{20,})["']?/i,
            PRIVATE_KEY: /-----BEGIN\s+(RSA\s+)?PRIVATE\s+KEY-----/,
            PASSWORD: /password\s*[:=]\s*["']?([^"'\s]{8,})["']?/i,
            TOKEN: /token\s*[:=]\s*["']?([A-Za-z0-9]{20,})["']?/i,
            SECRET: /secret\s*[:=]\s*["']?([A-Za-z0-9]{20,})["']?/i,
            DATABASE_URL: /(postgres|mysql|mongodb):\/\/[^\s"']+/i,
            GITHUB_TOKEN: /ghp_[A-Za-z0-9]{36}/,
            SLACK_TOKEN: /xox[baprs]-[0-9a-zA-Z-]{10,}/,
            STRIPE_KEY: /sk_live_[0-9a-zA-Z]{24,}/,
            DOCKER_PASSWORD: /docker[_-]?password\s*[:=]\s*["']?([A-Za-z0-9]{20,})["']?/i,
            KUBERNETES_SECRET: /kind:\s*Secret/i
        };
    }

    scanFile(filePath) {
        const findings = [];
        
        try {
            const content = fs.readFileSync(filePath, 'utf8');
            const lines = content.split('\n');
            
            lines.forEach((line, lineNum) => {
                Object.entries(this.patterns).forEach(([secretType, pattern]) => {
                    const matches = line.matchAll(new RegExp(pattern, 'gi'));
                    for (const match of matches) {
                        let secretValue = match[0];
                        if (secretValue.length > 20) {
                            secretValue = secretValue.substring(0, 10) + '...' + secretValue.substring(secretValue.length - 5);
                        } else {
                            secretValue = '***';
                        }
                        
                        findings.push({
                            severity: 'High',
                            type: secretType,
                            file: filePath,
                            line: lineNum + 1,
                            match: secretValue,
                            description: `Potential ${secretType} found in CI/CD pipeline`
                        });
                    }
                });
            });
        } catch (err) {
            console.log(`[-] Error scanning ${filePath}: ${err.message}`);
        }
        
        return findings;
    }

    scanCICDFiles(directory) {
        console.log(`[*] Scanning CI/CD files in: ${directory}...`);
        
        const findings = [];
        const cicdFiles = [];
        
        // GitHub Actions
        const githubWorkflows = path.join(directory, '.github', 'workflows');
        if (fs.existsSync(githubWorkflows)) {
            function walkDir(dir) {
                const files = fs.readdirSync(dir);
                files.forEach(file => {
                    const filePath = path.join(dir, file);
                    const stat = fs.statSync(filePath);
                    if (stat.isDirectory()) {
                        walkDir(filePath);
                    } else if (file.endsWith('.yml') || file.endsWith('.yaml')) {
                        cicdFiles.push(filePath);
                    }
                });
            }
            walkDir(githubWorkflows);
        }
        
        // GitLab CI
        const gitlabCI = path.join(directory, '.gitlab-ci.yml');
        if (fs.existsSync(gitlabCI)) {
            cicdFiles.push(gitlabCI);
        }
        
        // Jenkins
        const jenkinsfile = path.join(directory, 'Jenkinsfile');
        if (fs.existsSync(jenkinsfile)) {
            cicdFiles.push(jenkinsfile);
        }
        
        // CircleCI
        const circleciDir = path.join(directory, '.circleci');
        if (fs.existsSync(circleciDir)) {
            const configFile = path.join(circleciDir, 'config.yml');
            if (fs.existsSync(configFile)) {
                cicdFiles.push(configFile);
            }
        }
        
        // Azure DevOps
        const azurePipelines = path.join(directory, 'azure-pipelines.yml');
        if (fs.existsSync(azurePipelines)) {
            cicdFiles.push(azurePipelines);
        }
        
        cicdFiles.forEach(cicdFile => {
            findings.push(...this.scanFile(cicdFile));
        });
        
        return findings;
    }

    scanDirectory(directory) {
        console.log(`[*] Scanning directory: ${directory}...`);
        
        const findings = [];
        const excludedDirs = new Set(['.git', 'node_modules', '.venv', 'venv', '__pycache__', '.pytest_cache', 'dist', 'build']);
        const excludedExts = new Set(['.pyc', '.pyo', '.pyd', '.so', '.dll', '.exe', '.jpg', '.png', '.gif', '.pdf']);
        
        // First scan CI/CD specific files
        findings.push(...this.scanCICDFiles(directory));
        
        // Then scan all other files
        function walkDir(dir) {
            const files = fs.readdirSync(dir);
            
            files.forEach(file => {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                
                if (stat.isDirectory()) {
                    if (!excludedDirs.has(file)) {
                        walkDir(filePath);
                    }
                } else {
                    const ext = path.extname(file);
                    if (!excludedExts.has(ext)) {
                        // Skip already scanned CI/CD files
                        if (!filePath.includes('.github/workflows') && 
                            !filePath.includes('.gitlab-ci.yml') && 
                            !filePath.includes('Jenkinsfile') && 
                            !filePath.includes('.circleci') && 
                            !filePath.includes('azure-pipelines.yml')) {
                            findings.push(...this.scanFile(filePath));
                        }
                    }
                }
            });
        }
        
        walkDir.call(this, directory);
        return findings;
    }

    scan() {
        const stat = fs.statSync(this.targetPath);
        
        if (stat.isFile()) {
            this.findings = this.scanFile(this.targetPath);
        } else if (stat.isDirectory()) {
            this.findings = this.scanDirectory(this.targetPath);
        } else {
            console.log(`[-] Path not found: ${this.targetPath}`);
            return {};
        }
        
        return {
            findings: this.findings,
            totalSecrets: this.findings.length
        };
    }

    generateReport() {
        let report = `# Secret Scanning in CI/CD Report\n\n`;
        report += `**Target**: ${this.targetPath}\n\n`;
        
        if (this.findings.length > 0) {
            report += `## Summary\n\n`;
            report += `**Total Secrets Found**: ${this.findings.length}\n\n`;
            
            const byType = {};
            this.findings.forEach(finding => {
                if (!byType[finding.type]) {
                    byType[finding.type] = [];
                }
                byType[finding.type].push(finding);
            });
            
            report += `## Findings by Type\n\n`;
            Object.entries(byType).forEach(([secretType, findings]) => {
                report += `### ${secretType}: ${findings.length} found\n\n`;
            });
            
            const byFile = {};
            this.findings.forEach(finding => {
                if (!byFile[finding.file]) {
                    byFile[finding.file] = [];
                }
                byFile[finding.file].push(finding);
            });
            
            report += `## Findings by File\n\n`;
            Object.entries(byFile).slice(0, 20).forEach(([filePath, findings]) => {
                report += `### ${filePath}\n\n`;
                findings.slice(0, 5).forEach(finding => {
                    report += `- **Line ${finding.line}**: ${finding.type} - \`${finding.match}\`\n`;
                });
                report += `\n`;
            });
            
            if (Object.keys(byFile).length > 20) {
                report += `\n*... and ${Object.keys(byFile).length - 20} more files*\n\n`;
            }
        } else {
            report += `âœ… No secrets found.\n\n`;
        }
        
        report += `## Recommendations\n\n`;
        report += `1. **Remove secrets immediately** from code and git history\n`;
        report += `2. **Rotate all exposed credentials** immediately\n`;
        report += `3. **Use CI/CD secrets management**:\n`;
        report += `   - GitHub Secrets\n`;
        report += `   - GitLab CI/CD Variables\n`;
        report += `   - Jenkins Credentials\n`;
        report += `   - Azure Key Vault\n`;
        report += `4. **Add secrets to .gitignore**\n`;
        report += `5. **Use pre-commit hooks** to prevent secret commits\n`;
        report += `6. **Enable secret scanning** in CI/CD pipelines\n`;
        report += `7. **Review git history** for exposed secrets\n`;
        report += `8. **Use environment variables** instead of hardcoded values\n\n`;
        
        return report;
    }
}

function main() {
    if (process.argv.length < 3) {
        console.log('Usage: node secret_scanning_cicd.js <file_or_directory>');
        console.log('Example: node secret_scanning_cicd.js .github/workflows');
        console.log('Example: node secret_scanning_cicd.js /path/to/repo');
        process.exit(1);
    }
    
    const targetPath = process.argv[2];
    
    const scanner = new SecretScanningCICD(targetPath);
    scanner.scan();
    
    const report = scanner.generateReport();
    
    const filename = 'secret_scanning_cicd_report.md';
    fs.writeFileSync(filename, report, 'utf8');
    
    console.log(`[+] Secret scanning in CI/CD complete`);
    console.log(`[+] Report saved to ${filename}`);
    console.log(`[!] Found ${scanner.findings.length} potential secrets`);
    console.log('[!] WARNING: Review findings and rotate any exposed credentials immediately!');
}

if (require.main === module) {
    main();
}

module.exports = SecretScanningCICD;

