#!/usr/bin/env python3
"""
Windows Privilege Escalation Checker
Checks for common Windows privilege escalation vectors.
"""

import sys
import os
import subprocess
from typing import List, Dict

class WindowsPrivEsc:
    def __init__(self):
        self.findings = []
    
    def check_unquoted_service_paths(self) -> List[str]:
        """Check for unquoted service paths"""
        print("[*] Checking for unquoted service paths...")
        vulnerable_services = []
        
        try:
            result = subprocess.run(
                ['wmic', 'service', 'get', 'name,pathname'],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                lines = result.stdout.split('\n')
                for line in lines:
                    if ' ' in line and not line.strip().startswith('"'):
                        vulnerable_services.append(line.strip())
        except:
            pass
        
        return vulnerable_services
    
    def check_always_install_elevated(self) -> bool:
        """Check AlwaysInstallElevated registry"""
        print("[*] Checking AlwaysInstallElevated...")
        
        try:
            result = subprocess.run(
                ['reg', 'query', 'HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer', '/v', 'AlwaysInstallElevated'],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if '0x1' in result.stdout:
                return True
        except:
            pass
        
        return False
    
    def check_writable_registry_keys(self) -> List[str]:
        """Check for writable registry keys"""
        print("[*] Checking writable registry keys...")
        writable_keys = []
        
        sensitive_keys = [
            'HKLM\\SYSTEM\\CurrentControlSet\\Services',
            'HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run'
        ]
        
        # Simplified check
        return writable_keys
    
    def check_service_permissions(self) -> List[Dict]:
        """Check service permissions"""
        print("[*] Checking service permissions...")
        services = []
        
        try:
            result = subprocess.run(
                ['sc', 'query'],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                lines = result.stdout.split('\n')
                for line in lines:
                    if 'SERVICE_NAME' in line:
                        service_name = line.split(':')[1].strip()
                        services.append({'name': service_name})
        except:
            pass
        
        return services
    
    def check_dll_hijacking(self) -> List[str]:
        """Check for DLL hijacking opportunities"""
        print("[*] Checking for DLL hijacking...")
        opportunities = []
        
        # Check PATH environment variable
        path = os.environ.get('PATH', '')
        if path:
            paths = path.split(';')
            for p in paths:
                if os.access(p, os.W_OK):
                    opportunities.append(p)
        
        return opportunities
    
    def generate_report(self) -> str:
        """Generate privilege escalation report"""
        report = "# Windows Privilege Escalation Check Report\n\n"
        
        # Check unquoted service paths
        unquoted = self.check_unquoted_service_paths()
        if unquoted:
            report += "## Unquoted Service Paths\n\n"
            report += "⚠️ **WARNING**: Unquoted service paths found!\n\n"
            for service in unquoted[:5]:
                report += f"- {service}\n"
            report += "\n"
        
        # Check AlwaysInstallElevated
        always_elevated = self.check_always_install_elevated()
        if always_elevated:
            report += "## AlwaysInstallElevated\n\n"
            report += "⚠️ **CRITICAL**: AlwaysInstallElevated is enabled!\n\n"
        
        # Check DLL hijacking
        dll_hijack = self.check_dll_hijacking()
        if dll_hijack:
            report += "## DLL Hijacking Opportunities\n\n"
            for path in dll_hijack:
                report += f"- Writable PATH: {path}\n"
            report += "\n"
        
        report += "## Common Windows Privilege Escalation Techniques\n\n"
        report += "1. **Unquoted Service Paths**: Exploit services with unquoted paths\n"
        report += "2. **DLL Hijacking**: Replace DLLs in writable directories\n"
        report += "3. **Service Permissions**: Abuse misconfigured service permissions\n"
        report += "4. **Registry Misconfigurations**: Exploit writable registry keys\n"
        report += "5. **Kernel Exploits**: Use Windows kernel vulnerabilities\n\n"
        
        return report

def main():
    print("Windows Privilege Escalation Checker")
    print("⚠️ WARNING: Only run on systems you own or have permission to test!")
    
    checker = WindowsPrivEsc()
    
    report = checker.generate_report()
    
    filename = "windows_privesc_check.md"
    with open(filename, 'w') as f:
        f.write(report)
    
    print(f"[+] Privilege escalation check complete")
    print(f"[+] Report saved to {filename}")

if __name__ == '__main__':
    main()


