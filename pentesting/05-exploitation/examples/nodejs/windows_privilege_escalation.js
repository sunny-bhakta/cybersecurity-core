#!/usr/bin/env node
/**
 * Windows Privilege Escalation Checker
 * Checks for common Windows privilege escalation vectors.
 */

const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs');
const execAsync = promisify(exec);

class WindowsPrivEsc {
    constructor() {
        this.findings = [];
    }

    async checkUnquotedServicePaths() {
        console.log('[*] Checking for unquoted service paths...');
        const vulnerableServices = [];
        
        try {
            const { stdout } = await execAsync('wmic service get name,pathname', { timeout: 30000 });
            const lines = stdout.split('\n');
            for (const line of lines) {
                if (line.includes(' ') && !line.trim().startsWith('"')) {
                    vulnerableServices.push(line.trim());
                }
            }
        } catch (err) {
            // Ignore errors
        }
        
        return vulnerableServices;
    }

    async checkAlwaysInstallElevated() {
        console.log('[*] Checking AlwaysInstallElevated...');
        
        try {
            const { stdout } = await execAsync('reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated', { timeout: 10000 });
            if (stdout.includes('0x1')) {
                return true;
            }
        } catch (err) {
            // Ignore errors
        }
        
        return false;
    }

    checkDllHijacking() {
        console.log('[*] Checking for DLL hijacking...');
        const opportunities = [];
        
        const path = process.env.PATH || '';
        if (path) {
            const paths = path.split(';');
            for (const p of paths) {
                try {
                    if (fs.existsSync(p)) {
                        fs.accessSync(p, fs.constants.W_OK);
                        opportunities.push(p);
                    }
                } catch (err) {
                    // Not writable
                }
            }
        }
        
        return opportunities;
    }

    async generateReport() {
        let report = `# Windows Privilege Escalation Check Report\n\n`;
        
        const unquoted = await this.checkUnquotedServicePaths();
        if (unquoted.length > 0) {
            report += `## Unquoted Service Paths\n\n`;
            report += `⚠️ **WARNING**: Unquoted service paths found!\n\n`;
            unquoted.slice(0, 5).forEach(service => {
                report += `- ${service}\n`;
            });
            report += `\n`;
        }
        
        const alwaysElevated = await this.checkAlwaysInstallElevated();
        if (alwaysElevated) {
            report += `## AlwaysInstallElevated\n\n`;
            report += `⚠️ **CRITICAL**: AlwaysInstallElevated is enabled!\n\n`;
        }
        
        const dllHijack = this.checkDllHijacking();
        if (dllHijack.length > 0) {
            report += `## DLL Hijacking Opportunities\n\n`;
            dllHijack.forEach(path => {
                report += `- Writable PATH: ${path}\n`;
            });
            report += `\n`;
        }
        
        report += `## Common Windows Privilege Escalation Techniques\n\n`;
        report += `1. **Unquoted Service Paths**: Exploit services with unquoted paths\n`;
        report += `2. **DLL Hijacking**: Replace DLLs in writable directories\n`;
        report += `3. **Service Permissions**: Abuse misconfigured service permissions\n`;
        report += `4. **Registry Misconfigurations**: Exploit writable registry keys\n`;
        report += `5. **Kernel Exploits**: Use Windows kernel vulnerabilities\n\n`;
        
        return report;
    }
}

async function main() {
    console.log('Windows Privilege Escalation Checker');
    console.log('='.repeat(50));
    console.log('⚠️ WARNING: Only run on systems you own or have permission to test!');
    
    const checker = new WindowsPrivEsc();
    const report = await checker.generateReport();
    
    const filename = 'windows_privesc_check.md';
    fs.writeFileSync(filename, report, 'utf8');
    
    console.log(`\n[+] Privilege escalation check complete`);
    console.log(`[+] Report saved to ${filename}`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = WindowsPrivEsc;

