#!/usr/bin/env node
/**
 * Linux Privilege Escalation Checker
 * Checks for common Linux privilege escalation vectors.
 */

const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs');
const execAsync = promisify(exec);

class LinuxPrivEsc {
    constructor() {
        this.findings = [];
    }

    async checkSuidBinaries() {
        console.log('[*] Checking for SUID binaries...');
        const suidBinaries = [];
        
        try {
            const { stdout } = await execAsync('find /usr /bin -perm -4000 2>/dev/null', { timeout: 30000 });
            const binaries = stdout.trim().split('\n').filter(b => b.length > 0);
            suidBinaries.push(...binaries);
        } catch (err) {
            // Ignore errors
        }
        
        return suidBinaries;
    }

    async checkSudoPermissions() {
        console.log('[*] Checking sudo permissions...');
        
        const sudoInfo = {
            canSudo: false,
            commands: []
        };
        
        try {
            const { stdout } = await execAsync('sudo -l', { timeout: 10000 });
            sudoInfo.canSudo = true;
            sudoInfo.commands = stdout.split('\n');
        } catch (err) {
            // User may not have sudo access
        }
        
        return sudoInfo;
    }

    checkWritableFiles() {
        console.log('[*] Checking for writable files...');
        const writable = [];
        
        const sensitivePaths = [
            '/etc/passwd',
            '/etc/shadow',
            '/etc/crontab',
            '/etc/cron.d/',
            '/var/spool/cron/'
        ];
        
        for (const path of sensitivePaths) {
            try {
                if (fs.existsSync(path)) {
                    fs.accessSync(path, fs.constants.W_OK);
                    writable.push(path);
                }
            } catch (err) {
                // Not writable
            }
        }
        
        return writable;
    }

    checkCronJobs() {
        console.log('[*] Checking cron jobs...');
        const cronJobs = [];
        
        const cronFiles = [
            '/etc/crontab',
            '/etc/cron.d/',
            '/var/spool/cron/crontabs/'
        ];
        
        for (const cronFile of cronFiles) {
            try {
                if (fs.existsSync(cronFile)) {
                    const content = fs.readFileSync(cronFile, 'utf8');
                    cronJobs.push({
                        file: cronFile,
                        content: content
                    });
                }
            } catch (err) {
                // Ignore errors
            }
        }
        
        return cronJobs;
    }

    async checkCapabilities() {
        console.log('[*] Checking Linux capabilities...');
        const capabilities = [];
        
        try {
            const { stdout } = await execAsync('getcap -r / 2>/dev/null', { timeout: 30000 });
            capabilities.push(...stdout.trim().split('\n').filter(c => c.length > 0));
        } catch (err) {
            // Ignore errors
        }
        
        return capabilities;
    }

    async generateReport() {
        let report = `# Linux Privilege Escalation Check Report\n\n`;
        
        const suid = await this.checkSuidBinaries();
        if (suid.length > 0) {
            report += `## SUID Binaries Found\n\n`;
            suid.slice(0, 10).forEach(binary => {
                report += `- ${binary}\n`;
            });
            report += `\n`;
        }
        
        const sudo = await this.checkSudoPermissions();
        if (sudo.canSudo) {
            report += `## Sudo Permissions\n\n`;
            report += `⚠️ User can use sudo!\n\n`;
            if (sudo.commands.length > 0) {
                report += `**Allowed commands**:\n`;
                sudo.commands.slice(0, 5).forEach(cmd => {
                    report += `- ${cmd}\n`;
                });
                report += `\n`;
            }
        }
        
        const writable = this.checkWritableFiles();
        if (writable.length > 0) {
            report += `## Writable Sensitive Files\n\n`;
            report += `⚠️ **WARNING**: Writable sensitive files found!\n\n`;
            writable.forEach(file => {
                report += `- ${file}\n`;
            });
            report += `\n`;
        }
        
        const cron = this.checkCronJobs();
        if (cron.length > 0) {
            report += `## Cron Jobs Found\n\n`;
            cron.forEach(job => {
                report += `**File**: ${job.file}\n\n`;
            });
            report += `\n`;
        }
        
        const caps = await this.checkCapabilities();
        if (caps.length > 0) {
            report += `## Linux Capabilities\n\n`;
            caps.slice(0, 5).forEach(cap => {
                report += `- ${cap}\n`;
            });
            report += `\n`;
        }
        
        report += `## Common Privilege Escalation Techniques\n\n`;
        report += `1. **SUID Binaries**: Exploit misconfigured SUID binaries\n`;
        report += `2. **Sudo Misconfigurations**: Abuse sudo permissions\n`;
        report += `3. **Cron Jobs**: Exploit writable cron jobs\n`;
        report += `4. **Kernel Exploits**: Use kernel vulnerabilities\n`;
        report += `5. **PATH Hijacking**: Manipulate PATH variable\n\n`;
        
        return report;
    }
}

async function main() {
    console.log('Linux Privilege Escalation Checker');
    console.log('='.repeat(50));
    console.log('⚠️ WARNING: Only run on systems you own or have permission to test!');
    
    const checker = new LinuxPrivEsc();
    const report = await checker.generateReport();
    
    const filename = 'linux_privesc_check.md';
    fs.writeFileSync(filename, report, 'utf8');
    
    console.log(`\n[+] Privilege escalation check complete`);
    console.log(`[+] Report saved to ${filename}`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = LinuxPrivEsc;

