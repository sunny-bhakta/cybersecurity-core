#!/usr/bin/env python3
"""
Network Analyzer
Analyzes network traffic and performs network infrastructure testing.
"""

import socket
import struct
import sys
import time
from typing import List, Dict, Optional
from collections import defaultdict

class NetworkAnalyzer:
    def __init__(self):
        self.hosts = []
        self.services = defaultdict(list)
        self.network_info = {}
    
    def arp_scan(self, network: str) -> List[str]:
        """Perform ARP scan to discover hosts on network"""
        print(f"[*] Performing ARP scan on {network}...")
        
        # Parse network (e.g., 192.168.1.0/24)
        if '/' in network:
            base_ip, mask = network.split('/')
            base_parts = base_ip.rsplit('.', 1)[0]
            hosts = [f"{base_parts}.{i}" for i in range(1, 255)]
        else:
            hosts = [network]
        
        live_hosts = []
        for host in hosts[:50]:  # Limit for demo
            try:
                # Try to ping (ICMP)
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(0.1)
                result = sock.connect_ex((host, 80))
                sock.close()
                
                if result == 0:
                    live_hosts.append(host)
                    print(f"[+] Host found: {host}")
            except:
                pass
        
        self.hosts = live_hosts
        return live_hosts
    
    def analyze_tcp_handshake(self, target: str, port: int) -> Dict:
        """Analyze TCP handshake"""
        print(f"[*] Analyzing TCP handshake to {target}:{port}...")
        
        result = {
            'target': target,
            'port': port,
            'status': 'closed',
            'ttl': None,
            'os_guess': None
        }
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            
            start_time = time.time()
            sock.connect((target, port))
            elapsed = time.time() - start_time
            
            # Get TTL from response
            result['status'] = 'open'
            result['ttl'] = 64  # Default, would need raw sockets for actual TTL
            result['response_time'] = elapsed
            
            # OS fingerprinting based on TTL
            if result['ttl']:
                if result['ttl'] <= 64:
                    result['os_guess'] = 'Linux/Unix'
                elif result['ttl'] <= 128:
                    result['os_guess'] = 'Windows'
                else:
                    result['os_guess'] = 'Unknown'
            
            sock.close()
        except socket.timeout:
            result['status'] = 'filtered'
        except Exception as e:
            result['error'] = str(e)
        
        return result
    
    def detect_firewall(self, target: str, ports: List[int]) -> Dict:
        """Detect firewall presence and rules"""
        print(f"[*] Detecting firewall on {target}...")
        
        results = {
            'target': target,
            'open_ports': [],
            'filtered_ports': [],
            'closed_ports': [],
            'firewall_detected': False
        }
        
        for port in ports:
            result = self.analyze_tcp_handshake(target, port)
            
            if result['status'] == 'open':
                results['open_ports'].append(port)
            elif result['status'] == 'filtered':
                results['filtered_ports'].append(port)
                results['firewall_detected'] = True
            else:
                results['closed_ports'].append(port)
        
        if results['firewall_detected']:
            print(f"[+] Firewall detected - {len(results['filtered_ports'])} filtered ports")
        
        return results
    
    def enumerate_smb_shares(self, target: str) -> List[str]:
        """Enumerate SMB shares"""
        print(f"[*] Enumerating SMB shares on {target}...")
        
        # Common SMB shares
        common_shares = ['C$', 'ADMIN$', 'IPC$', 'SHARED', 'PUBLIC']
        found_shares = []
        
        # In real scenario, use impacket or smbclient
        # This is a simplified example
        for share in common_shares:
            try:
                # Test share access
                found_shares.append(share)
                print(f"[+] Share found: {share}")
            except:
                pass
        
        return found_shares
    
    def test_vlan_hopping(self, target: str) -> bool:
        """Test for VLAN hopping vulnerability"""
        print(f"[*] Testing VLAN hopping on {target}...")
        
        # This requires special network setup
        # Simplified example
        print("[!] VLAN hopping test requires physical network access")
        return False
    
    def analyze_network_topology(self, network: str) -> Dict:
        """Analyze network topology"""
        print(f"[*] Analyzing network topology for {network}...")
        
        hosts = self.arp_scan(network)
        
        topology = {
            'network': network,
            'hosts_found': len(hosts),
            'hosts': hosts,
            'gateway': None,
            'dns_servers': []
        }
        
        # Try to identify gateway (usually .1 or .254)
        for ip in [f"{network.rsplit('.', 1)[0]}.1", f"{network.rsplit('.', 1)[0]}.254"]:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((ip, 80))
                sock.close()
                if result == 0:
                    topology['gateway'] = ip
                    break
            except:
                pass
        
        return topology
    
    def generate_report(self) -> str:
        """Generate network analysis report"""
        report = "# Network Infrastructure Analysis Report\n\n"
        report += "## Network Discovery\n\n"
        report += f"**Hosts Found**: {len(self.hosts)}\n\n"
        
        if self.hosts:
            report += "### Discovered Hosts\n\n"
            for host in self.hosts:
                report += f"- {host}\n"
        
        report += "\n## Services Detected\n\n"
        for service, ports in self.services.items():
            report += f"### {service}\n"
            for port in ports:
                report += f"- Port {port}\n"
        
        return report

def main():
    import sys
    
    analyzer = NetworkAnalyzer()
    
    if len(sys.argv) < 2:
        print("Usage: python network_analyzer.py <network> [action]")
        print("Example: python network_analyzer.py 192.168.1.0/24 scan")
        print("         python network_analyzer.py 192.168.1.100 firewall")
        sys.exit(1)
    
    target = sys.argv[1]
    action = sys.argv[2] if len(sys.argv) > 2 else 'scan'
    
    if action == 'scan':
        hosts = analyzer.arp_scan(target)
        print(f"\n[+] Found {len(hosts)} live hosts")
    
    elif action == 'firewall':
        ports = [22, 80, 443, 3389, 445]
        results = analyzer.detect_firewall(target, ports)
        print(f"\n[+] Firewall detection complete")
        print(f"    Open ports: {len(results['open_ports'])}")
        print(f"    Filtered ports: {len(results['filtered_ports'])}")
    
    elif action == 'topology':
        topology = analyzer.analyze_network_topology(target)
        print(f"\n[+] Network topology analysis complete")
        print(f"    Hosts: {topology['hosts_found']}")
        print(f"    Gateway: {topology['gateway']}")
    
    elif action == 'smb':
        shares = analyzer.enumerate_smb_shares(target)
        print(f"\n[+] Found {len(shares)} SMB shares")
    
    # Generate report
    report = analyzer.generate_report()
    with open('network_analysis_report.md', 'w') as f:
        f.write(report)
    
    print(f"\n[+] Report saved to network_analysis_report.md")
    print(f"[!] WARNING: Only test on networks you own or have permission to test!")

if __name__ == '__main__':
    main()

