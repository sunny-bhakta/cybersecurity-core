#!/usr/bin/env python3
"""
SSL/TLS Scanner
Scans SSL/TLS configurations for security issues.
"""

import sys
import socket
import ssl
from typing import Dict, List

class SSLTLSScanner:
    def __init__(self, host: str, port: int = 443):
        self.host = host
        self.port = port
        self.findings = []
    
    def scan_ssl(self) -> Dict:
        """Scan SSL/TLS configuration"""
        print(f"[*] Scanning SSL/TLS on {self.host}:{self.port}...")
        
        info = {
            'version': None,
            'cipher': None,
            'certificate': None,
            'vulnerabilities': []
        }
        
        try:
            context = ssl.create_default_context()
            with socket.create_connection((self.host, self.port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=self.host) as ssock:
                    info['version'] = ssock.version()
                    info['cipher'] = ssock.cipher()
                    
                    cert = ssock.getpeercert()
                    info['certificate'] = {
                        'subject': dict(x[0] for x in cert['subject']),
                        'issuer': dict(x[0] for x in cert['issuer']),
                        'version': cert['version'],
                        'notBefore': cert['notBefore'],
                        'notAfter': cert['notAfter']
                    }
                    
                    # Check for vulnerabilities
                    if 'SSL' in info['version']:
                        info['vulnerabilities'].append('Using deprecated SSL protocol')
                    
                    if info['cipher'] and 'RC4' in str(info['cipher']):
                        info['vulnerabilities'].append('Using weak RC4 cipher')
                    
        except Exception as e:
            print(f"[-] Error scanning SSL: {e}")
        
        return info
    
    def generate_report(self) -> str:
        """Generate SSL/TLS scan report"""
        info = self.scan_ssl()
        
        report = f"# SSL/TLS Scan Report for {self.host}:{self.port}\n\n"
        
        report += "## SSL/TLS Information\n\n"
        report += f"**Protocol Version**: {info['version'] or 'Not detected'}\n\n"
        report += f"**Cipher Suite**: {info['cipher'] or 'Not detected'}\n\n"
        
        if info['certificate']:
            report += "## Certificate Information\n\n"
            cert = info['certificate']
            report += f"**Subject**: {cert['subject']}\n\n"
            report += f"**Issuer**: {cert['issuer']}\n\n"
            report += f"**Valid From**: {cert['notBefore']}\n\n"
            report += f"**Valid Until**: {cert['notAfter']}\n\n"
        
        if info['vulnerabilities']:
            report += "## Vulnerabilities Found\n\n"
            for vuln in info['vulnerabilities']:
                report += f"⚠️ {vuln}\n"
            report += "\n"
        else:
            report += "✅ No obvious vulnerabilities detected.\n\n"
        
        report += "## Recommendations\n\n"
        report += "1. Use TLS 1.2 or higher\n"
        report += "2. Disable weak ciphers (RC4, DES, MD5)\n"
        report += "3. Use strong cipher suites\n"
        report += "4. Keep certificates updated\n"
        report += "5. Implement HSTS (HTTP Strict Transport Security)\n\n"
        
        return report

def main():
    if len(sys.argv) < 2:
        print("Usage: python ssl_tls_scanner.py <host> [port]")
        print("Example: python ssl_tls_scanner.py example.com 443")
        sys.exit(1)
    
    host = sys.argv[1]
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 443
    
    scanner = SSLTLSScanner(host, port)
    
    report = scanner.generate_report()
    
    filename = f"ssl_scan_{host.replace('.', '_')}.md"
    with open(filename, 'w') as f:
        f.write(report)
    
    print(f"[+] SSL/TLS scan complete for {host}:{port}")
    print(f"[+] Report saved to {filename}")

if __name__ == '__main__':
    main()

