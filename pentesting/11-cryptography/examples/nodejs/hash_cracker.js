/**
 * Hash Cracker
 * Cracks password hashes using dictionary and brute force attacks.
 */

const crypto = require('crypto');
const fs = require('fs');
const readline = require('readline');

class HashCracker {
    constructor() {
        this.hashFunctions = {
            md5: (text) => crypto.createHash('md5').update(text).digest('hex'),
            sha1: (text) => crypto.createHash('sha1').update(text).digest('hex'),
            sha256: (text) => crypto.createHash('sha256').update(text).digest('hex'),
            sha512: (text) => crypto.createHash('sha512').update(text).digest('hex')
        };
    }

    identifyHash(hashValue) {
        const length = hashValue.length;
        const hashTypes = {
            32: 'md5',
            40: 'sha1',
            64: 'sha256',
            128: 'sha512'
        };
        return hashTypes[length] || null;
    }

    hashPassword(password, algorithm = 'md5') {
        if (!this.hashFunctions[algorithm]) {
            throw new Error(`Unsupported algorithm: ${algorithm}`);
        }
        return this.hashFunctions[algorithm](password);
    }

    async dictionaryAttack(hashValue, wordlist, algorithm = 'md5') {
        console.log(`[*] Starting dictionary attack (${wordlist.length} words)...`);
        
        for (let i = 0; i < wordlist.length; i++) {
            if (i % 1000 === 0) {
                console.log(`[*] Tried ${i} passwords...`);
            }
            
            const word = wordlist[i];
            const hashed = this.hashPassword(word, algorithm);
            
            if (hashed === hashValue) {
                console.log(`[+] Password found: ${word}`);
                return word;
            }
        }
        
        console.log('[-] Password not found in dictionary');
        return null;
    }

    bruteForceAttack(hashValue, maxLength = 4, algorithm = 'md5', charset = 'abcdefghijklmnopqrstuvwxyz') {
        console.log(`[*] Starting brute force attack (max length: ${maxLength})...`);
        
        const generateCombinations = (length) => {
            const combinations = [];
            const chars = charset.split('');
            
            const generate = (current, remaining) => {
                if (remaining === 0) {
                    combinations.push(current);
                    return;
                }
                for (const char of chars) {
                    generate(current + char, remaining - 1);
                }
            };
            
            generate('', length);
            return combinations;
        };
        
        for (let length = 1; length <= maxLength; length++) {
            console.log(`[*] Trying length ${length}...`);
            const combinations = generateCombinations(length);
            
            for (const password of combinations) {
                const hashed = this.hashPassword(password, algorithm);
                if (hashed === hashValue) {
                    console.log(`[+] Password found: ${password}`);
                    return password;
                }
            }
        }
        
        console.log('[-] Password not found');
        return null;
    }

    async hybridAttack(hashValue, wordlist, algorithm = 'md5', suffixes = ['123', '!', '2024']) {
        console.log(`[*] Starting hybrid attack...`);
        
        for (const word of wordlist) {
            // Try word as-is
            let hashed = this.hashPassword(word, algorithm);
            if (hashed === hashValue) {
                console.log(`[+] Password found: ${word}`);
                return word;
            }
            
            // Try with suffixes
            for (const suffix of suffixes) {
                const password = word + suffix;
                hashed = this.hashPassword(password, algorithm);
                if (hashed === hashValue) {
                    console.log(`[+] Password found: ${password}`);
                    return password;
                }
            }
        }
        
        console.log('[-] Password not found');
        return null;
    }

    async crackHash(hashValue, wordlist = null, algorithm = null, method = 'dictionary') {
        if (!algorithm) {
            algorithm = this.identifyHash(hashValue);
            if (!algorithm) {
                console.log('[-] Could not identify hash type');
                return null;
            }
            console.log(`[+] Identified hash type: ${algorithm}`);
        }
        
        if (method === 'dictionary' && wordlist) {
            return await this.dictionaryAttack(hashValue, wordlist, algorithm);
        } else if (method === 'bruteforce') {
            return this.bruteForceAttack(hashValue, 4, algorithm);
        } else if (method === 'hybrid' && wordlist) {
            return await this.hybridAttack(hashValue, wordlist, algorithm);
        } else {
            console.log('[-] Invalid method or missing wordlist');
            return null;
        }
    }
}

async function main() {
    const args = process.argv.slice(2);
    if (args.length < 1) {
        console.log('Usage: node hash_cracker.js <hash> [wordlist_file] [algorithm] [method]');
        console.log('Example: node hash_cracker.js 5f4dcc3b5aa765d61d8327deb882cf99 wordlist.txt md5 dictionary');
        process.exit(1);
    }
    
    const cracker = new HashCracker();
    const hashValue = args[0];
    const wordlistFile = args[1] || null;
    const algorithm = args[2] || null;
    const method = args[3] || 'dictionary';
    
    let wordlist = [];
    if (wordlistFile) {
        try {
            const data = fs.readFileSync(wordlistFile, 'utf8');
            wordlist = data.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            console.log(`[+] Loaded ${wordlist.length} words from ${wordlistFile}`);
        } catch (error) {
            console.log(`[-] Wordlist file not found: ${wordlistFile}`);
            process.exit(1);
        }
    }
    
    const password = await cracker.crackHash(hashValue, wordlist, algorithm, method);
    
    if (password) {
        console.log(`\n[+] SUCCESS: Password is '${password}'`);
    } else {
        console.log(`\n[-] FAILED: Could not crack hash`);
    }
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = HashCracker;

