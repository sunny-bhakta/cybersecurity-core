#!/usr/bin/env python3
"""
Lateral Movement Tools
Tools for lateral movement in post-exploitation.
WARNING: For authorized security testing only!
"""

import socket
import subprocess
import sys
import os
from typing import List, Dict, Optional

class LateralMovement:
    def __init__(self):
        self.connections = []
        self.credentials = []
    
    def test_smb_connection(self, target: str, username: str, 
                           password: str, domain: str = '') -> bool:
        """Test SMB connection for lateral movement"""
        try:
            # Use impacket or similar for actual SMB connection
            # This is a simplified example
            print(f"[*] Testing SMB connection to {target}...")
            print(f"    Username: {username}")
            print(f"    Domain: {domain if domain else 'N/A'}")
            
            # In real scenario, use impacket's smbclient
            # For now, just simulate
            return True
        except Exception as e:
            print(f"[-] SMB connection failed: {e}")
            return False
    
    def execute_remote_command_wmi(self, target: str, command: str, 
                                  username: str, password: str) -> Optional[str]:
        """Execute command via WMI (Windows)"""
        try:
            print(f"[*] Executing command via WMI on {target}...")
            print(f"    Command: {command}")
            
            # Use impacket's wmiexec for actual execution
            # This is a simplified example
            wmi_cmd = f'wmic /node:{target} /user:{username} /password:{password} process call create "{command}"'
            
            # In real scenario, use impacket
            print(f"[+] Command executed via WMI")
            return "Command output here"
        except Exception as e:
            print(f"[-] WMI execution failed: {e}")
            return None
    
    def execute_remote_command_ssh(self, target: str, command: str,
                                  username: str, password: str = None,
                                  key_file: str = None) -> Optional[str]:
        """Execute command via SSH"""
        try:
            print(f"[*] Executing command via SSH on {target}...")
            print(f"    Command: {command}")
            
            # Use paramiko for actual SSH connection
            # This is a simplified example
            if key_file:
                ssh_cmd = f'ssh -i {key_file} {username}@{target} "{command}"'
            else:
                ssh_cmd = f'ssh {username}@{target} "{command}"'
            
            result = subprocess.run(ssh_cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                print(f"[+] SSH command executed successfully")
                return result.stdout
            else:
                print(f"[-] SSH command failed: {result.stderr}")
                return None
        except Exception as e:
            print(f"[-] SSH execution failed: {e}")
            return None
    
    def pass_the_hash(self, target: str, username: str, ntlm_hash: str,
                     domain: str = '', command: str = 'whoami') -> bool:
        """Pass-the-Hash attack for lateral movement"""
        try:
            print(f"[*] Attempting Pass-the-Hash to {target}...")
            print(f"    Username: {username}")
            print(f"    Domain: {domain if domain else 'N/A'}")
            print(f"    Hash: {ntlm_hash[:16]}...")
            
            # Use impacket's psexec or wmiexec with hash
            # This is a simplified example
            print(f"[+] Pass-the-Hash successful")
            return True
        except Exception as e:
            print(f"[-] Pass-the-Hash failed: {e}")
            return False
    
    def enumerate_network_shares(self, target: str) -> List[str]:
        """Enumerate network shares on target"""
        try:
            print(f"[*] Enumerating shares on {target}...")
            
            # Use smbclient or similar
            shares = []
            # Simplified example
            common_shares = ['C$', 'ADMIN$', 'IPC$', 'SHARED']
            
            for share in common_shares:
                # Test if share exists
                shares.append(share)
            
            print(f"[+] Found {len(shares)} shares")
            return shares
        except Exception as e:
            print(f"[-] Share enumeration failed: {e}")
            return []
    
    def scan_network_hosts(self, network: str, ports: List[int] = [445, 3389, 22]) -> List[Dict]:
        """Scan network for potential lateral movement targets"""
        print(f"[*] Scanning network {network}...")
        
        # Parse network (e.g., 192.168.1.0/24)
        if '/' in network:
            base_ip, mask = network.split('/')
            # Simplified - in real scenario, use ipaddress module
            hosts = [f"{base_ip.rsplit('.', 1)[0]}.{i}" for i in range(1, 255)]
        else:
            hosts = [network]
        
        results = []
        for host in hosts[:10]:  # Limit for demo
            for port in ports:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(1)
                    result = sock.connect_ex((host, port))
                    sock.close()
                    
                    if result == 0:
                        results.append({
                            'host': host,
                            'port': port,
                            'service': self.get_service_name(port)
                        })
                        print(f"[+] {host}:{port} - {self.get_service_name(port)}")
                except:
                    pass
        
        return results
    
    def get_service_name(self, port: int) -> str:
        """Get service name from port"""
        services = {
            22: 'SSH',
            445: 'SMB',
            3389: 'RDP',
            5985: 'WinRM',
            5986: 'WinRM HTTPS'
        }
        return services.get(port, 'Unknown')
    
    def generate_report(self) -> str:
        """Generate lateral movement report"""
        report = "# Lateral Movement Report\n\n"
        report += "## Network Connections\n\n"
        
        if self.connections:
            for conn in self.connections:
                report += f"- **{conn['target']}**: {conn['method']}\n"
        else:
            report += "No connections established.\n"
        
        report += "\n## Credentials Used\n\n"
        if self.credentials:
            for cred in self.credentials:
                report += f"- **{cred['username']}@{cred['domain']}**: Used for {cred['target']}\n"
        else:
            report += "No credentials used.\n"
        
        return report

def main():
    movement = LateralMovement()
    
    if len(sys.argv) < 2:
        print("Usage:")
        print("  python lateral_movement.py ssh <target> <user> <command>")
        print("  python lateral_movement.py wmi <target> <user> <pass> <command>")
        print("  python lateral_movement.py pth <target> <user> <hash>")
        print("  python lateral_movement.py scan <network>")
        print("  python lateral_movement.py shares <target>")
        sys.exit(1)
    
    action = sys.argv[1]
    
    if action == 'ssh':
        if len(sys.argv) < 5:
            print("Usage: python lateral_movement.py ssh <target> <user> <command>")
            sys.exit(1)
        target = sys.argv[2]
        user = sys.argv[3]
        command = sys.argv[4]
        movement.execute_remote_command_ssh(target, command, user)
    
    elif action == 'wmi':
        if len(sys.argv) < 6:
            print("Usage: python lateral_movement.py wmi <target> <user> <pass> <command>")
            sys.exit(1)
        target = sys.argv[2]
        user = sys.argv[3]
        password = sys.argv[4]
        command = sys.argv[5]
        movement.execute_remote_command_wmi(target, command, user, password)
    
    elif action == 'pth':
        if len(sys.argv) < 5:
            print("Usage: python lateral_movement.py pth <target> <user> <hash>")
            sys.exit(1)
        target = sys.argv[2]
        user = sys.argv[3]
        ntlm_hash = sys.argv[4]
        movement.pass_the_hash(target, user, ntlm_hash)
    
    elif action == 'scan':
        network = sys.argv[2] if len(sys.argv) > 2 else '192.168.1.0/24'
        results = movement.scan_network_hosts(network)
        print(f"\n[+] Found {len(results)} accessible services")
    
    elif action == 'shares':
        target = sys.argv[2] if len(sys.argv) > 2 else '192.168.1.100'
        shares = movement.enumerate_network_shares(target)
        print(f"\n[+] Found {len(shares)} shares")
    
    # Generate report
    report = movement.generate_report()
    with open('lateral_movement_report.md', 'w') as f:
        f.write(report)
    
    print(f"\n[+] Report saved to lateral_movement_report.md")
    print(f"[!] WARNING: Only use on systems you own or have permission to test!")

if __name__ == '__main__':
    main()

