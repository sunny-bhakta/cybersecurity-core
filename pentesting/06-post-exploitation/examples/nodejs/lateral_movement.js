/**
 * Lateral Movement Tools
 * Tools for lateral movement in post-exploitation.
 * WARNING: For authorized security testing only!
 */

const { exec } = require('child_process');
const net = require('net');
const fs = require('fs');

class LateralMovement {
    constructor() {
        this.connections = [];
        this.credentials = [];
    }

    testSMBConnection(target, username, password, domain = '') {
        console.log(`[*] Testing SMB connection to ${target}...`);
        console.log(`    Username: ${username}`);
        console.log(`    Domain: ${domain || 'N/A'}`);
        // In real scenario, use SMB library
        return true;
    }

    executeRemoteCommandSSH(target, command, username, password = null, keyFile = null) {
        return new Promise((resolve, reject) => {
            console.log(`[*] Executing command via SSH on ${target}...`);
            console.log(`    Command: ${command}`);

            let sshCmd;
            if (keyFile) {
                sshCmd = `ssh -i ${keyFile} ${username}@${target} "${command}"`;
            } else {
                sshCmd = `ssh ${username}@${target} "${command}"`;
            }

            exec(sshCmd, (error, stdout, stderr) => {
                if (error) {
                    console.log(`[-] SSH command failed: ${error.message}`);
                    resolve(null);
                } else {
                    console.log(`[+] SSH command executed successfully`);
                    resolve(stdout);
                }
            });
        });
    }

    executeRemoteCommandWMI(target, command, username, password) {
        console.log(`[*] Executing command via WMI on ${target}...`);
        console.log(`    Command: ${command}`);
        // Use impacket or similar for actual WMI execution
        console.log(`[+] Command executed via WMI`);
        return 'Command output here';
    }

    passTheHash(target, username, ntlmHash, domain = '', command = 'whoami') {
        console.log(`[*] Attempting Pass-the-Hash to ${target}...`);
        console.log(`    Username: ${username}`);
        console.log(`    Domain: ${domain || 'N/A'}`);
        console.log(`    Hash: ${ntlmHash.substring(0, 16)}...`);
        // Use impacket for actual PTH
        console.log(`[+] Pass-the-Hash successful`);
        return true;
    }

    enumerateNetworkShares(target) {
        console.log(`[*] Enumerating shares on ${target}...`);
        // Use SMB library for actual enumeration
        const commonShares = ['C$', 'ADMIN$', 'IPC$', 'SHARED'];
        console.log(`[+] Found ${commonShares.length} shares`);
        return commonShares;
    }

    scanNetworkHosts(network, ports = [445, 3389, 22]) {
        return new Promise((resolve) => {
            console.log(`[*] Scanning network ${network}...`);

            let hosts = [];
            if (network.includes('/')) {
                const [baseIP] = network.split('/');
                const baseParts = baseIP.split('.');
                for (let i = 1; i < 255; i++) {
                    hosts.push(`${baseParts[0]}.${baseParts[1]}.${baseParts[2]}.${i}`);
                }
            } else {
                hosts = [network];
            }

            const results = [];
            let completed = 0;
            const total = Math.min(hosts.length, 10) * ports.length;

            hosts.slice(0, 10).forEach(host => {
                ports.forEach(port => {
                    const socket = new net.Socket();
                    socket.setTimeout(1000);

                    socket.on('connect', () => {
                        results.push({
                            host: host,
                            port: port,
                            service: this.getServiceName(port)
                        });
                        console.log(`[+] ${host}:${port} - ${this.getServiceName(port)}`);
                        socket.destroy();
                        completed++;
                        if (completed === total) {
                            resolve(results);
                        }
                    });

                    socket.on('timeout', () => {
                        socket.destroy();
                        completed++;
                        if (completed === total) {
                            resolve(results);
                        }
                    });

                    socket.on('error', () => {
                        socket.destroy();
                        completed++;
                        if (completed === total) {
                            resolve(results);
                        }
                    });

                    socket.connect(port, host);
                });
            });
        });
    }

    getServiceName(port) {
        const services = {
            22: 'SSH',
            445: 'SMB',
            3389: 'RDP',
            5985: 'WinRM',
            5986: 'WinRM HTTPS'
        };
        return services[port] || 'Unknown';
    }

    generateReport() {
        let report = `# Lateral Movement Report\n\n`;
        report += `## Network Connections\n\n`;

        if (this.connections.length > 0) {
            this.connections.forEach(conn => {
                report += `- **${conn.target}**: ${conn.method}\n`;
            });
        } else {
            report += `No connections established.\n`;
        }

        report += `\n## Credentials Used\n\n`;
        if (this.credentials.length > 0) {
            this.credentials.forEach(cred => {
                report += `- **${cred.username}@${cred.domain}**: Used for ${cred.target}\n`;
            });
        } else {
            report += `No credentials used.\n`;
        }

        return report;
    }
}

async function main() {
    const args = process.argv.slice(2);
    const movement = new LateralMovement();

    if (args.length < 1) {
        console.log('Usage:');
        console.log('  node lateral_movement.js ssh <target> <user> <command>');
        console.log('  node lateral_movement.js wmi <target> <user> <pass> <command>');
        console.log('  node lateral_movement.js pth <target> <user> <hash>');
        console.log('  node lateral_movement.js scan <network>');
        console.log('  node lateral_movement.js shares <target>');
        process.exit(1);
    }

    const action = args[0];

    if (action === 'ssh') {
        if (args.length < 4) {
            console.log('Usage: node lateral_movement.js ssh <target> <user> <command>');
            process.exit(1);
        }
        const target = args[1];
        const user = args[2];
        const command = args[3];
        await movement.executeRemoteCommandSSH(target, command, user);
    } else if (action === 'wmi') {
        if (args.length < 5) {
            console.log('Usage: node lateral_movement.js wmi <target> <user> <pass> <command>');
            process.exit(1);
        }
        const target = args[1];
        const user = args[2];
        const password = args[3];
        const command = args[4];
        movement.executeRemoteCommandWMI(target, command, user, password);
    } else if (action === 'pth') {
        if (args.length < 4) {
            console.log('Usage: node lateral_movement.js pth <target> <user> <hash>');
            process.exit(1);
        }
        const target = args[1];
        const user = args[2];
        const ntlmHash = args[3];
        movement.passTheHash(target, user, ntlmHash);
    } else if (action === 'scan') {
        const network = args[1] || '192.168.1.0/24';
        const results = await movement.scanNetworkHosts(network);
        console.log(`\n[+] Found ${results.length} accessible services`);
    } else if (action === 'shares') {
        const target = args[1] || '192.168.1.100';
        const shares = movement.enumerateNetworkShares(target);
        console.log(`\n[+] Found ${shares.length} shares`);
    }

    const report = movement.generateReport();
    fs.writeFileSync('lateral_movement_report.md', report, 'utf8');

    console.log(`\n[+] Report saved to lateral_movement_report.md`);
    console.log(`[!] WARNING: Only use on systems you own or have permission to test!`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = LateralMovement;

