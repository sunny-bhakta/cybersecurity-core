#!/usr/bin/env python3
"""
Dependency Confusion Tester
Tests for dependency confusion vulnerabilities.
"""

import sys
import os
import json
import requests
from typing import Dict, List

class DependencyConfusionTester:
    def __init__(self, project_path: str = '.'):
        self.project_path = project_path
        self.findings = []
        self.public_registries = {
            'npm': 'https://registry.npmjs.org',
            'pypi': 'https://pypi.org',
            'maven': 'https://repo1.maven.org/maven2',
            'nuget': 'https://api.nuget.org/v3'
        }
    
    def check_npm_packages(self) -> List[Dict]:
        """Check npm packages for dependency confusion"""
        print("[*] Checking npm packages for dependency confusion...")
        
        findings = []
        package_json = os.path.join(self.project_path, 'package.json')
        
        if not os.path.exists(package_json):
            return findings
        
        try:
            with open(package_json, 'r') as f:
                package_data = json.load(f)
            
            dependencies = {}
            dependencies.update(package_data.get('dependencies', {}))
            dependencies.update(package_data.get('devDependencies', {}))
            
            for package_name, version in dependencies.items():
                # Check if package exists in public registry
                try:
                    response = requests.get(
                        f"{self.public_registries['npm']}/{package_name}",
                        timeout=10
                    )
                    
                    if response.status_code == 200:
                        public_package = response.json()
                        latest_version = public_package.get('dist-tags', {}).get('latest', '')
                        
                        # Check if private package name matches public package
                        if latest_version:
                            findings.append({
                                'severity': 'High',
                                'issue': f'Potential Dependency Confusion: {package_name}',
                                'description': f'Package {package_name} exists in public npm registry',
                                'package': package_name,
                                'version': version,
                                'public_version': latest_version,
                                'package_manager': 'npm'
                            })
                except:
                    pass
        except Exception as e:
            print(f"[-] Error checking npm packages: {e}")
        
        return findings
    
    def check_pip_packages(self) -> List[Dict]:
        """Check pip packages for dependency confusion"""
        print("[*] Checking pip packages for dependency confusion...")
        
        findings = []
        requirements_files = [
            os.path.join(self.project_path, 'requirements.txt'),
            os.path.join(self.project_path, 'setup.py'),
            os.path.join(self.project_path, 'pyproject.toml')
        ]
        
        packages = []
        
        for req_file in requirements_files:
            if os.path.exists(req_file):
                try:
                    with open(req_file, 'r') as f:
                        content = f.read()
                        # Simple parsing - in real implementation would use proper parser
                        for line in content.split('\n'):
                            line = line.strip()
                            if line and not line.startswith('#'):
                                package_name = line.split('==')[0].split('>=')[0].split('<=')[0].strip()
                                if package_name:
                                    packages.append(package_name)
                except:
                    pass
        
        for package_name in packages:
            # Check if package exists in public PyPI
            try:
                response = requests.get(
                    f"{self.public_registries['pypi']}/pypi/{package_name}/json",
                    timeout=10
                )
                
                if response.status_code == 200:
                    public_package = response.json()
                    latest_version = public_package.get('info', {}).get('version', '')
                    
                    if latest_version:
                        findings.append({
                            'severity': 'High',
                            'issue': f'Potential Dependency Confusion: {package_name}',
                            'description': f'Package {package_name} exists in public PyPI',
                            'package': package_name,
                            'public_version': latest_version,
                            'package_manager': 'pip'
                        })
            except:
                pass
        
        return findings
    
    def test_all(self) -> Dict:
        """Test for dependency confusion vulnerabilities"""
        print(f"[*] Testing for dependency confusion in: {self.project_path}\n")
        
        self.findings.extend(self.check_npm_packages())
        self.findings.extend(self.check_pip_packages())
        
        return {
            'findings': self.findings,
            'total_issues': len(self.findings)
        }
    
    def generate_report(self) -> str:
        """Generate dependency confusion test report"""
        report = f"# Dependency Confusion Test Report\n\n"
        report += f"**Project Path**: {self.project_path}\n\n"
        
        if self.findings:
            report += f"## Summary\n\n"
            report += f"Total Issues Found: {len(self.findings)}\n\n"
            
            # Group by package manager
            by_manager = {}
            for finding in self.findings:
                manager = finding.get('package_manager', 'Unknown')
                if manager not in by_manager:
                    by_manager[manager] = []
                by_manager[manager].append(finding)
            
            report += "## Findings by Package Manager\n\n"
            for manager, findings in by_manager.items():
                report += f"### {manager.upper()}: {len(findings)} issues\n\n"
            
            report += "## Detailed Findings\n\n"
            for i, finding in enumerate(self.findings, 1):
                report += f"### {i}. {finding['issue']}\n\n"
                report += f"**Severity**: {finding['severity']}\n\n"
                report += f"**Description**: {finding['description']}\n\n"
                report += f"**Package**: {finding['package']}\n\n"
                if 'version' in finding:
                    report += f"**Local Version**: {finding['version']}\n\n"
                if 'public_version' in finding:
                    report += f"**Public Version**: {finding['public_version']}\n\n"
                report += "---\n\n"
        else:
            report += "âœ… No dependency confusion vulnerabilities found.\n\n"
        
        report += "## Dependency Confusion Overview\n\n"
        report += "Dependency confusion attacks occur when an attacker publishes a malicious\n"
        report += "package to a public registry with the same name as a private/internal package.\n"
        report += "If the package manager resolves to the public registry, the malicious package\n"
        report += "may be installed instead of the intended private package.\n\n"
        
        report += "## Prevention\n\n"
        report += "1. Use scoped packages (npm: @company/package)\n"
        report += "2. Configure private registry with higher priority\n"
        report += "3. Use package signing and verification\n"
        report += "4. Monitor for package name conflicts\n"
        report += "5. Use unique package names for private packages\n"
        report += "6. Implement package name reservation\n"
        report += "7. Use lock files to pin exact versions\n\n"
        
        return report

def main():
    project_path = sys.argv[1] if len(sys.argv) > 1 else '.'
    
    tester = DependencyConfusionTester(project_path)
    tester.test_all()
    
    report = tester.generate_report()
    
    filename = "dependency_confusion_test.md"
    with open(filename, 'w') as f:
        f.write(report)
    
    print(f"[+] Dependency confusion testing complete")
    print(f"[+] Report saved to {filename}")
    print(f"[!] Found {len(tester.findings)} potential issues")

if __name__ == "__main__":
    main()

