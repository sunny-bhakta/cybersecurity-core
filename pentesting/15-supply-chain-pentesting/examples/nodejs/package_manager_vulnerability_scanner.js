#!/usr/bin/env node
/**
 * Package Manager Vulnerability Scanner
 * Scans package manager files for known vulnerabilities.
 */

const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs');
const path = require('path');
const execAsync = promisify(exec);

class PackageManagerVulnerabilityScanner {
    constructor(projectPath = '.') {
        this.projectPath = projectPath;
        this.findings = [];
    }

    async scanNpm() {
        console.log('[*] Scanning npm packages...');
        
        const packageJson = path.join(this.projectPath, 'package.json');
        if (!fs.existsSync(packageJson)) {
            return {};
        }
        
        try {
            const { stdout, stderr } = await execAsync(
                'npm audit --json',
                { cwd: this.projectPath, timeout: 300000 }
            );
            
            if (stdout) {
                const auditData = JSON.parse(stdout);
                return this.parseNpmAudit(auditData);
            }
        } catch (err) {
            if (err.message.includes('not found') || err.code === 'ENOENT') {
                console.log('[-] npm not found');
            } else {
                console.log(`[-] Error running npm audit: ${err.message}`);
            }
        }
        
        return {};
    }

    parseNpmAudit(auditData) {
        const findings = [];
        
        const vulnerabilities = auditData.vulnerabilities || {};
        
        Object.entries(vulnerabilities).forEach(([packageName, vulnData]) => {
            if (typeof vulnData === 'object') {
                const severity = vulnData.severity || 'Unknown';
                const via = vulnData.via || [];
                
                via.forEach(vuln => {
                    if (typeof vuln === 'object') {
                        findings.push({
                            severity: severity.toUpperCase(),
                            package: packageName,
                            vulnerabilityId: vuln.source || 'Unknown',
                            title: vuln.title || '',
                            description: vuln.description || '',
                            packageManager: 'npm'
                        });
                    }
                });
            }
        });
        
        this.findings.push(...findings);
        return {
            findings,
            totalVulnerabilities: findings.length
        };
    }

    async scanPip() {
        console.log('[*] Scanning pip packages...');
        
        const requirementsFiles = [
            path.join(this.projectPath, 'requirements.txt'),
            path.join(this.projectPath, 'requirements-dev.txt'),
            path.join(this.projectPath, 'Pipfile'),
            path.join(this.projectPath, 'pyproject.toml')
        ];
        
        const findings = [];
        
        for (const reqFile of requirementsFiles) {
            if (fs.existsSync(reqFile)) {
                try {
                    const { stdout, stderr } = await execAsync(
                        `safety check --json --file ${reqFile}`,
                        { timeout: 300000 }
                    );
                    
                    if (stdout) {
                        const safetyData = JSON.parse(stdout);
                        safetyData.forEach(vuln => {
                            findings.push({
                                severity: (vuln.severity || 'Unknown').toUpperCase(),
                                package: vuln.package || 'Unknown',
                                vulnerabilityId: vuln.vulnerability_id || 'Unknown',
                                title: vuln.advisory || '',
                                description: vuln.advisory || '',
                                packageManager: 'pip'
                            });
                        });
                    }
                } catch (err) {
                    if (err.message.includes('not found')) {
                        console.log('[-] safety not found. Install with: pip install safety');
                    } else {
                        console.log(`[-] Error running safety: ${err.message}`);
                    }
                }
            }
        }
        
        this.findings.push(...findings);
        return {
            findings,
            totalVulnerabilities: findings.length
        };
    }

    async scanAll() {
        console.log(`[*] Scanning package managers in: ${this.projectPath}\n`);
        
        await this.scanNpm();
        await this.scanPip();
        
        return {
            findings: this.findings,
            totalVulnerabilities: this.findings.length
        };
    }

    generateReport() {
        let report = `# Package Manager Vulnerability Scan Report\n\n`;
        report += `**Project Path**: ${this.projectPath}\n\n`;
        
        if (this.findings.length > 0) {
            report += `## Summary\n\n`;
            report += `Total Vulnerabilities: ${this.findings.length}\n\n`;
            
            const byManager = {};
            this.findings.forEach(finding => {
                const manager = finding.packageManager || 'Unknown';
                if (!byManager[manager]) {
                    byManager[manager] = [];
                }
                byManager[manager].push(finding);
            });
            
            Object.entries(byManager).forEach(([manager, findings]) => {
                report += `### ${manager.toUpperCase()}: ${findings.length} vulnerabilities\n\n`;
            });
            
            const critical = this.findings.filter(f => f.severity === 'CRITICAL');
            const high = this.findings.filter(f => f.severity === 'HIGH');
            const medium = this.findings.filter(f => f.severity === 'MEDIUM');
            
            report += `- **Critical**: ${critical.length}\n`;
            report += `- **High**: ${high.length}\n`;
            report += `- **Medium**: ${medium.length}\n\n`;
            
            report += `## Findings\n\n`;
            this.findings.slice(0, 50).forEach((finding, i) => {
                report += `### ${i + 1}. ${finding.package} - ${finding.vulnerabilityId}\n\n`;
                report += `**Severity**: ${finding.severity}\n\n`;
                report += `**Package Manager**: ${finding.packageManager}\n\n`;
                report += `**Title**: ${finding.title}\n\n`;
                if (finding.description) {
                    report += `**Description**: ${finding.description.substring(0, 200)}...\n\n`;
                }
                report += `---\n\n`;
            });
            
            if (this.findings.length > 50) {
                report += `\n*... and ${this.findings.length - 50} more vulnerabilities*\n\n`;
            }
        } else {
            report += `âœ… No vulnerabilities found.\n\n`;
        }
        
        report += `## Recommendations\n\n`;
        report += `1. Update vulnerable packages to patched versions\n`;
        report += `2. Use automated dependency scanning in CI/CD\n`;
        report += `3. Enable Dependabot or similar tools\n`;
        report += `4. Review and test updates before deploying\n`;
        report += `5. Use lock files (package-lock.json, Pipfile.lock)\n`;
        report += `6. Monitor for new vulnerabilities\n`;
        report += `7. Use security advisories from package maintainers\n\n`;
        
        return report;
    }
}

async function main() {
    const projectPath = process.argv[2] || '.';
    
    const scanner = new PackageManagerVulnerabilityScanner(projectPath);
    await scanner.scanAll();
    
    const report = scanner.generateReport();
    
    const filename = 'package_manager_vulnerability_scan.md';
    fs.writeFileSync(filename, report, 'utf8');
    
    console.log(`[+] Package manager vulnerability scan complete`);
    console.log(`[+] Report saved to ${filename}`);
    console.log(`[!] Found ${scanner.findings.length} vulnerabilities`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = PackageManagerVulnerabilityScanner;

