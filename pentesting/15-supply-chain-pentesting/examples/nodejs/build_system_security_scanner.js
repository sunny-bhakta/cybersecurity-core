#!/usr/bin/env node
/**
 * Build System Security Scanner
 * Scans build system configurations for security issues.
 */

const fs = require('fs');
const path = require('path');

class BuildSystemSecurityScanner {
    constructor(projectPath = '.') {
        this.projectPath = projectPath;
        this.findings = [];
    }

    scanMaven() {
        console.log('[*] Scanning Maven build configuration...');
        
        const findings = [];
        const pomXml = path.join(this.projectPath, 'pom.xml');
        
        if (!fs.existsSync(pomXml)) {
            return findings;
        }
        
        try {
            const content = fs.readFileSync(pomXml, 'utf8');
            
            if (content.includes('http://') && content.toLowerCase().includes('repository')) {
                findings.push({
                    severity: 'Medium',
                    issue: 'Insecure Maven Repository',
                    description: 'Maven uses HTTP instead of HTTPS for repositories',
                    file: pomXml
                });
            }
            
            if (content.toLowerCase().includes('repository') && !content.toLowerCase().includes('maven-central')) {
                findings.push({
                    severity: 'Low',
                    issue: 'External Maven Repository',
                    description: 'Maven uses external repositories (potential supply chain risk)',
                    file: pomXml
                });
            }
        } catch (err) {
            console.log(`[-] Error scanning Maven: ${err.message}`);
        }
        
        return findings;
    }

    scanGradle() {
        console.log('[*] Scanning Gradle build configuration...');
        
        const findings = [];
        const buildGradle = path.join(this.projectPath, 'build.gradle');
        const buildGradleKts = path.join(this.projectPath, 'build.gradle.kts');
        
        const gradleFiles = [buildGradle, buildGradleKts].filter(f => fs.existsSync(f));
        
        gradleFiles.forEach(gradleFile => {
            try {
                const content = fs.readFileSync(gradleFile, 'utf8');
                
                if (content.includes('http://') && content.includes('repositories')) {
                    findings.push({
                        severity: 'Medium',
                        issue: 'Insecure Gradle Repository',
                        description: 'Gradle uses HTTP instead of HTTPS for repositories',
                        file: gradleFile
                    });
                }
                
                if (content.includes('allowInsecureProtocol')) {
                    findings.push({
                        severity: 'High',
                        issue: 'Insecure Protocol Allowed',
                        description: 'Gradle allows insecure protocols',
                        file: gradleFile
                    });
                }
            } catch (err) {
                console.log(`[-] Error scanning Gradle: ${err.message}`);
            }
        });
        
        return findings;
    }

    scanDockerfile() {
        console.log('[*] Scanning Dockerfile...');
        
        const findings = [];
        const dockerfile = path.join(this.projectPath, 'Dockerfile');
        
        if (!fs.existsSync(dockerfile)) {
            return findings;
        }
        
        try {
            const lines = fs.readFileSync(dockerfile, 'utf8').split('\n');
            
            lines.forEach((line, i) => {
                if (line.trim().startsWith('USER root') || line.includes('USER 0')) {
                    findings.push({
                        severity: 'Medium',
                        issue: 'Running as Root',
                        description: 'Container runs as root user',
                        file: dockerfile,
                        line: i + 1
                    });
                }
                
                if (line.includes('RUN') && (line.toLowerCase().includes('password') || line.toLowerCase().includes('secret'))) {
                    findings.push({
                        severity: 'High',
                        issue: 'Potential Secret in Build',
                        description: 'Potential secret exposed in Dockerfile',
                        file: dockerfile,
                        line: i + 1
                    });
                }
                
                if (line.includes('FROM') && line.includes(':latest')) {
                    findings.push({
                        severity: 'Low',
                        issue: 'Using Latest Tag',
                        description: 'Dockerfile uses :latest tag (unpredictable builds)',
                        file: dockerfile,
                        line: i + 1
                    });
                }
            });
        } catch (err) {
            console.log(`[-] Error scanning Dockerfile: ${err.message}`);
        }
        
        return findings;
    }

    scanMakefile() {
        console.log('[*] Scanning Makefile...');
        
        const findings = [];
        const makefile = path.join(this.projectPath, 'Makefile');
        
        if (!fs.existsSync(makefile)) {
            return findings;
        }
        
        try {
            const content = fs.readFileSync(makefile, 'utf8');
            
            if (content.toLowerCase().includes('password') || content.toLowerCase().includes('secret')) {
                findings.push({
                    severity: 'High',
                    issue: 'Potential Hardcoded Credentials',
                    description: 'Makefile may contain hardcoded credentials',
                    file: makefile
                });
            }
            
            const unsafeCommands = ['rm -rf', 'chmod 777', 'curl | sh', 'wget | sh'];
            unsafeCommands.forEach(cmd => {
                if (content.includes(cmd)) {
                    findings.push({
                        severity: 'Medium',
                        issue: `Unsafe Command: ${cmd}`,
                        description: `Makefile contains potentially unsafe command: ${cmd}`,
                        file: makefile
                    });
                }
            });
        } catch (err) {
            console.log(`[-] Error scanning Makefile: ${err.message}`);
        }
        
        return findings;
    }

    scanAll() {
        console.log(`[*] Scanning build systems in: ${this.projectPath}\n`);
        
        this.findings.push(...this.scanMaven());
        this.findings.push(...this.scanGradle());
        this.findings.push(...this.scanDockerfile());
        this.findings.push(...this.scanMakefile());
        
        return {
            findings: this.findings
        };
    }

    generateReport() {
        let report = `# Build System Security Scan Report\n\n`;
        report += `**Project Path**: ${this.projectPath}\n\n`;
        
        if (this.findings.length > 0) {
            report += `## Summary\n\n`;
            report += `Total Findings: ${this.findings.length}\n\n`;
            
            const critical = this.findings.filter(f => f.severity === 'Critical');
            const high = this.findings.filter(f => f.severity === 'High');
            const medium = this.findings.filter(f => f.severity === 'Medium');
            const low = this.findings.filter(f => f.severity === 'Low');
            
            report += `- **Critical**: ${critical.length}\n`;
            report += `- **High**: ${high.length}\n`;
            report += `- **Medium**: ${medium.length}\n`;
            report += `- **Low**: ${low.length}\n\n`;
            
            report += `## Findings\n\n`;
            this.findings.forEach((finding, i) => {
                report += `### ${i + 1}. ${finding.issue}\n\n`;
                report += `**Severity**: ${finding.severity}\n\n`;
                report += `**Description**: ${finding.description}\n\n`;
                report += `**File**: \`${finding.file}\`\n\n`;
                if (finding.line) {
                    report += `**Line**: ${finding.line}\n\n`;
                }
                report += `---\n\n`;
            });
        } else {
            report += `âœ… No security issues found.\n\n`;
        }
        
        report += `## Best Practices\n\n`;
        report += `1. Use HTTPS for all repository URLs\n`;
        report += `2. Pin dependency versions (avoid latest)\n`;
        report += `3. Use signed artifacts and verify signatures\n`;
        report += `4. Run builds as non-root user\n`;
        report += `5. Don't hardcode secrets in build files\n`;
        report += `6. Use build secrets management\n`;
        report += `7. Scan dependencies before building\n`;
        report += `8. Use reproducible builds\n\n`;
        
        return report;
    }
}

function main() {
    const projectPath = process.argv[2] || '.';
    
    const scanner = new BuildSystemSecurityScanner(projectPath);
    scanner.scanAll();
    
    const report = scanner.generateReport();
    
    const filename = 'build_system_security_scan.md';
    fs.writeFileSync(filename, report, 'utf8');
    
    console.log(`[+] Build system security scan complete`);
    console.log(`[+] Report saved to ${filename}`);
}

if (require.main === module) {
    main();
}

module.exports = BuildSystemSecurityScanner;

