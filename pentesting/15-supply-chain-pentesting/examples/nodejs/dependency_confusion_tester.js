#!/usr/bin/env node
/**
 * Dependency Confusion Tester
 * Tests for dependency confusion vulnerabilities.
 */

const https = require('https');
const http = require('http');
const fs = require('fs');
const path = require('path');

class DependencyConfusionTester {
    constructor(projectPath = '.') {
        this.projectPath = projectPath;
        this.findings = [];
        this.publicRegistries = {
            npm: 'registry.npmjs.org',
            pypi: 'pypi.org',
            maven: 'repo1.maven.org',
            nuget: 'api.nuget.org'
        };
    }

    makeRequest(hostname, path) {
        return new Promise((resolve, reject) => {
            const options = {
                hostname,
                path,
                method: 'GET',
                timeout: 10000
            };
            
            const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => {
                    data += chunk;
                });
                res.on('end', () => {
                    resolve({ statusCode: res.statusCode, data });
                });
            });
            
            req.on('error', (err) => {
                reject(err);
            });
            
            req.on('timeout', () => {
                req.destroy();
                reject(new Error('Request timeout'));
            });
            
            req.end();
        });
    }

    async checkNpmPackages() {
        console.log('[*] Checking npm packages for dependency confusion...');
        
        const findings = [];
        const packageJson = path.join(this.projectPath, 'package.json');
        
        if (!fs.existsSync(packageJson)) {
            return findings;
        }
        
        try {
            const packageData = JSON.parse(fs.readFileSync(packageJson, 'utf8'));
            
            const dependencies = {
                ...packageData.dependencies || {},
                ...packageData.devDependencies || {}
            };
            
            for (const [packageName, version] of Object.entries(dependencies)) {
                try {
                    const response = await this.makeRequest(
                        this.publicRegistries.npm,
                        `/${packageName}`
                    );
                    
                    if (response.statusCode === 200) {
                        const publicPackage = JSON.parse(response.data);
                        const latestVersion = publicPackage['dist-tags']?.latest || '';
                        
                        if (latestVersion) {
                            findings.push({
                                severity: 'High',
                                issue: `Potential Dependency Confusion: ${packageName}`,
                                description: `Package ${packageName} exists in public npm registry`,
                                package: packageName,
                                version: version,
                                publicVersion: latestVersion,
                                packageManager: 'npm'
                            });
                        }
                    }
                } catch (err) {
                    // Ignore errors
                }
            }
        } catch (err) {
            console.log(`[-] Error checking npm packages: ${err.message}`);
        }
        
        return findings;
    }

    async checkPipPackages() {
        console.log('[*] Checking pip packages for dependency confusion...');
        
        const findings = [];
        const requirementsFiles = [
            path.join(this.projectPath, 'requirements.txt'),
            path.join(this.projectPath, 'setup.py'),
            path.join(this.projectPath, 'pyproject.toml')
        ];
        
        const packages = [];
        
        requirementsFiles.forEach(reqFile => {
            if (fs.existsSync(reqFile)) {
                try {
                    const content = fs.readFileSync(reqFile, 'utf8');
                    content.split('\n').forEach(line => {
                        line = line.trim();
                        if (line && !line.startsWith('#')) {
                            const packageName = line.split('==')[0].split('>=')[0].split('<=')[0].trim();
                            if (packageName) {
                                packages.push(packageName);
                            }
                        }
                    });
                } catch (err) {
                    // Ignore errors
                }
            }
        });
        
        for (const packageName of packages) {
            try {
                const response = await this.makeRequest(
                    this.publicRegistries.pypi,
                    `/pypi/${packageName}/json`
                );
                
                if (response.statusCode === 200) {
                    const publicPackage = JSON.parse(response.data);
                    const latestVersion = publicPackage.info?.version || '';
                    
                    if (latestVersion) {
                        findings.push({
                            severity: 'High',
                            issue: `Potential Dependency Confusion: ${packageName}`,
                            description: `Package ${packageName} exists in public PyPI`,
                            package: packageName,
                            publicVersion: latestVersion,
                            packageManager: 'pip'
                        });
                    }
                }
            } catch (err) {
                // Ignore errors
            }
        }
        
        return findings;
    }

    async testAll() {
        console.log(`[*] Testing for dependency confusion in: ${this.projectPath}\n`);
        
        this.findings.push(...await this.checkNpmPackages());
        this.findings.push(...await this.checkPipPackages());
        
        return {
            findings: this.findings,
            totalIssues: this.findings.length
        };
    }

    generateReport() {
        let report = `# Dependency Confusion Test Report\n\n`;
        report += `**Project Path**: ${this.projectPath}\n\n`;
        
        if (this.findings.length > 0) {
            report += `## Summary\n\n`;
            report += `Total Issues Found: ${this.findings.length}\n\n`;
            
            const byManager = {};
            this.findings.forEach(finding => {
                const manager = finding.packageManager || 'Unknown';
                if (!byManager[manager]) {
                    byManager[manager] = [];
                }
                byManager[manager].push(finding);
            });
            
            report += `## Findings by Package Manager\n\n`;
            Object.entries(byManager).forEach(([manager, findings]) => {
                report += `### ${manager.toUpperCase()}: ${findings.length} issues\n\n`;
            });
            
            report += `## Detailed Findings\n\n`;
            this.findings.forEach((finding, i) => {
                report += `### ${i + 1}. ${finding.issue}\n\n`;
                report += `**Severity**: ${finding.severity}\n\n`;
                report += `**Description**: ${finding.description}\n\n`;
                report += `**Package**: ${finding.package}\n\n`;
                if (finding.version) {
                    report += `**Local Version**: ${finding.version}\n\n`;
                }
                if (finding.publicVersion) {
                    report += `**Public Version**: ${finding.publicVersion}\n\n`;
                }
                report += `---\n\n`;
            });
        } else {
            report += `âœ… No dependency confusion vulnerabilities found.\n\n`;
        }
        
        report += `## Dependency Confusion Overview\n\n`;
        report += `Dependency confusion attacks occur when an attacker publishes a malicious\n`;
        report += `package to a public registry with the same name as a private/internal package.\n`;
        report += `If the package manager resolves to the public registry, the malicious package\n`;
        report += `may be installed instead of the intended private package.\n\n`;
        
        report += `## Prevention\n\n`;
        report += `1. Use scoped packages (npm: @company/package)\n`;
        report += `2. Configure private registry with higher priority\n`;
        report += `3. Use package signing and verification\n`;
        report += `4. Monitor for package name conflicts\n`;
        report += `5. Use unique package names for private packages\n`;
        report += `6. Implement package name reservation\n`;
        report += `7. Use lock files to pin exact versions\n\n`;
        
        return report;
    }
}

async function main() {
    const projectPath = process.argv[2] || '.';
    
    const tester = new DependencyConfusionTester(projectPath);
    await tester.testAll();
    
    const report = tester.generateReport();
    
    const filename = 'dependency_confusion_test.md';
    fs.writeFileSync(filename, report, 'utf8');
    
    console.log(`[+] Dependency confusion testing complete`);
    console.log(`[+] Report saved to ${filename}`);
    console.log(`[!] Found ${tester.findings.length} potential issues`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = DependencyConfusionTester;

