#!/usr/bin/env node
/**
 * Web Application Fingerprinting Tool
 * Identifies web applications and their versions.
 */

const https = require('https');
const http = require('http');
const fs = require('fs');

class WebAppFingerprinting {
    constructor(url) {
        this.url = url.replace(/\/$/, '');
        this.fingerprints = {};
        this.matches = [];
    }

    async checkHeaders() {
        console.log('[*] Checking HTTP headers...');
        
        const headersInfo = {};
        
        try {
            const protocol = this.url.startsWith('https') ? https : http;
            
            await new Promise((resolve, reject) => {
                protocol.get(this.url, { timeout: 10000, rejectUnauthorized: false }, (res) => {
                    if (res.headers['server']) {
                        headersInfo.server = res.headers['server'];
                    }
                    
                    if (res.headers['x-powered-by']) {
                        headersInfo.poweredBy = res.headers['x-powered-by'];
                    }
                    
                    if (res.headers['x-generator']) {
                        headersInfo.generator = res.headers['x-generator'];
                    }
                    
                    if (res.headers['set-cookie']) {
                        headersInfo.cookie = res.headers['set-cookie'];
                    }
                    
                    resolve();
                }).on('error', (err) => {
                    reject(err);
                });
            });
        } catch (err) {
            console.log(`[-] Error: ${err.message}`);
        }
        
        return headersInfo;
    }

    async checkHtmlContent() {
        console.log('[*] Checking HTML content...');
        
        const contentInfo = {};
        
        try {
            const protocol = this.url.startsWith('https') ? https : http;
            
            const html = await new Promise((resolve, reject) => {
                protocol.get(this.url, { timeout: 10000, rejectUnauthorized: false }, (res) => {
                    let data = '';
                    res.on('data', (chunk) => {
                        data += chunk;
                    });
                    res.on('end', () => {
                        resolve(data);
                    });
                }).on('error', (err) => {
                    reject(err);
                });
            });
            
            const htmlLower = html.toLowerCase();
            
            const cmsPatterns = {
                'WordPress': [/wp-content/, /wp-includes/, /\/wp-admin\//, /wordpress/],
                'Joomla': [/\/joomla\//, /joomla/, /option=com_/],
                'Drupal': [/\/sites\//, /drupal/, /\/modules\//, /\/themes\//],
                'Magento': [/magento/, /\/skin\//, /\/js\/mage\//],
                'Laravel': [/laravel_session/, /\/vendor\/laravel\//],
                'Django': [/csrfmiddlewaretoken/, /\/static\/admin\//],
                'React': [/react/, /__react/, /\/static\/js\//],
                'Vue.js': [/vue/, /__vue/, /\/dist\//],
                'Angular': [/angular/, /ng-/, /\/node_modules\//]
            };
            
            for (const [cms, patterns] of Object.entries(cmsPatterns)) {
                for (const pattern of patterns) {
                    if (pattern.test(htmlLower)) {
                        contentInfo[cms] = true;
                        this.matches.push(`${cms} detected via HTML content`);
                        break;
                    }
                }
            }
            
            // Check for meta generator tags
            const generatorMatch = html.match(/<meta\s+name=["']generator["']\s+content=["']([^"']+)["']/i);
            if (generatorMatch) {
                contentInfo.metaGenerator = generatorMatch[1];
                this.matches.push(`Generator: ${generatorMatch[1]}`);
            }
            
            // Check for common paths
            const commonPaths = [
                '/wp-admin/', '/wp-content/', '/wp-includes/',
                '/administrator/', '/admin/', '/cpanel/',
                '/phpmyadmin/', '/.git/', '/.env'
            ];
            
            for (const path of commonPaths) {
                try {
                    const testUrl = `${this.url}${path}`;
                    const testProtocol = testUrl.startsWith('https') ? https : http;
                    
                    await new Promise((resolve) => {
                        testProtocol.get(testUrl, { timeout: 5000, rejectUnauthorized: false }, (res) => {
                            if ([200, 301, 302, 403].includes(res.statusCode)) {
                                contentInfo[`path_${path.replace(/\//g, '_')}`] = true;
                                this.matches.push(`Path found: ${path}`);
                            }
                            resolve();
                        }).on('error', () => {
                            resolve();
                        });
                    });
                } catch (err) {
                    // Ignore errors
                }
            }
        } catch (err) {
            console.log(`[-] Error: ${err.message}`);
        }
        
        return contentInfo;
    }

    async checkRobotsTxt() {
        console.log('[*] Checking robots.txt...');
        
        const robotsInfo = {};
        
        try {
            const robotsUrl = `${this.url}/robots.txt`;
            const protocol = robotsUrl.startsWith('https') ? https : http;
            
            const robotsContent = await new Promise((resolve, reject) => {
                protocol.get(robotsUrl, { timeout: 5000, rejectUnauthorized: false }, (res) => {
                    if (res.statusCode === 200) {
                        let data = '';
                        res.on('data', (chunk) => {
                            data += chunk;
                        });
                        res.on('end', () => {
                            resolve(data.toLowerCase());
                        });
                    } else {
                        resolve('');
                    }
                }).on('error', () => {
                    resolve('');
                });
            });
            
            if (robotsContent.includes('wp-admin')) {
                robotsInfo.wordpress = true;
                this.matches.push('WordPress detected via robots.txt');
            }
            
            if (robotsContent.includes('administrator')) {
                robotsInfo.joomla = true;
                this.matches.push('Joomla detected via robots.txt');
            }
        } catch (err) {
            // Ignore errors
        }
        
        return robotsInfo;
    }

    async fingerprint() {
        console.log(`[*] Starting web application fingerprinting for ${this.url}\n`);
        
        const results = {
            headers: await this.checkHeaders(),
            content: await this.checkHtmlContent(),
            robots: await this.checkRobotsTxt()
        };
        
        return results;
    }

    generateReport(results) {
        let report = `# Web Application Fingerprinting Report\n\n`;
        report += `**Target**: ${this.url}\n\n`;
        
        if (Object.keys(results.headers).length > 0) {
            report += `## HTTP Headers\n\n`;
            for (const [key, value] of Object.entries(results.headers)) {
                report += `**${key}**: ${value}\n`;
            }
            report += `\n`;
        }
        
        if (Object.keys(results.content).length > 0) {
            report += `## Content Analysis\n\n`;
            const detectedApps = Object.keys(results.content).filter(k => 
                results.content[k] === true && !k.startsWith('path_')
            );
            
            if (detectedApps.length > 0) {
                report += `### Detected Applications\n\n`;
                detectedApps.forEach(app => {
                    report += `- ${app}\n`;
                });
                report += `\n`;
            }
            
            if (results.content.metaGenerator) {
                report += `**Meta Generator**: ${results.content.metaGenerator}\n\n`;
            }
        }
        
        if (this.matches.length > 0) {
            report += `## Detection Matches\n\n`;
            this.matches.forEach(match => {
                report += `- ${match}\n`;
            });
            report += `\n`;
        }
        
        if (Object.keys(results.robots).length > 0) {
            report += `## Robots.txt Analysis\n\n`;
            for (const [key, value] of Object.entries(results.robots)) {
                if (value) {
                    report += `- ${key.charAt(0).toUpperCase() + key.slice(1)} detected\n`;
                }
            }
            report += `\n`;
        }
        
        report += `## Security Implications\n\n`;
        report += `1. **Technology Disclosure**: Reveals application stack\n`;
        report += `2. **Version Information**: May reveal specific versions\n`;
        report += `3. **Attack Surface**: Identifies potential attack vectors\n`;
        report += `4. **Vulnerability Research**: Helps identify known vulnerabilities\n\n`;
        
        report += `## Recommendations\n\n`;
        report += `1. Hide or modify server headers\n`;
        report += `2. Remove generator meta tags\n`;
        report += `3. Restrict access to sensitive paths\n`;
        report += `4. Use security headers\n`;
        report += `5. Regularly update applications\n\n`;
        
        return report;
    }
}

// Main execution
async function main() {
    if (process.argv.length < 3) {
        console.log('Usage: node web_app_fingerprinting.js <url>');
        console.log('Example: node web_app_fingerprinting.js http://example.com');
        process.exit(1);
    }
    
    const url = process.argv[2];
    
    const fingerprinter = new WebAppFingerprinting(url);
    
    const results = await fingerprinter.fingerprint();
    const report = fingerprinter.generateReport(results);
    
    const filename = 'web_app_fingerprint.md';
    fs.writeFileSync(filename, report, 'utf8');
    
    console.log(`\n[+] Web application fingerprinting complete`);
    console.log(`[+] Report saved to ${filename}`);
    console.log(`[!] WARNING: Only test applications you own or have permission to test!`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = WebAppFingerprinting;

