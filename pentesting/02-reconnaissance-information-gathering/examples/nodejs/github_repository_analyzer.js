#!/usr/bin/env node
/**
 * GitHub Repository Analyzer
 * Analyzes GitHub repositories for security issues and exposed information.
 */

const https = require('https');
const fs = require('fs');

class GitHubRepositoryAnalyzer {
    constructor(owner, repo = null) {
        this.owner = owner;
        this.repo = repo;
        this.findings = [];
        this.apiBase = 'api.github.com';
    }

    makeRequest(path) {
        return new Promise((resolve, reject) => {
            const options = {
                hostname: this.apiBase,
                path: path,
                method: 'GET',
                headers: {
                    'User-Agent': 'GitHub-Repository-Analyzer'
                }
            };

            https.get(options, (res) => {
                let data = '';
                res.on('data', (chunk) => {
                    data += chunk;
                });
                res.on('end', () => {
                    try {
                        resolve(JSON.parse(data));
                    } catch (e) {
                        resolve(data);
                    }
                });
            }).on('error', (err) => {
                reject(err);
            });
        });
    }

    async analyzeRepository() {
        if (!this.repo) {
            return {};
        }

        console.log(`[*] Analyzing repository: ${this.owner}/${this.repo}`);

        const findings = {
            secrets: [],
            exposedFiles: [],
            vulnerabilities: [],
            sensitiveInfo: []
        };

        const sensitiveFiles = [
            '.env', '.gitignore', 'config.json', 'secrets.json',
            'credentials.txt', 'passwords.txt', 'private_key.pem'
        ];

        for (const file of sensitiveFiles) {
            try {
                const path = `/repos/${this.owner}/${this.repo}/contents/${file}`;
                const data = await this.makeRequest(path);
                if (data && !data.message) {
                    findings.exposedFiles.push(file);
                    console.log(`[!] Found exposed file: ${file}`);
                }
            } catch (err) {
                // File not found or error
            }
        }

        return findings;
    }

    async listRepositories() {
        console.log(`[*] Listing repositories for: ${this.owner}`);

        try {
            const path = `/users/${this.owner}/repos`;
            const repos = await this.makeRequest(path);
            return Array.isArray(repos) ? repos : [];
        } catch (err) {
            console.log(`[-] Error: ${err.message}`);
            return [];
        }
    }

    async generateReport() {
        let report = `# GitHub Repository Analysis Report\n\n`;
        report += `**Target**: ${this.owner}`;
        if (this.repo) {
            report += ` / ${this.repo}`;
        }
        report += `\n\n`;

        if (this.repo) {
            const findings = await this.analyzeRepository();

            if (findings.exposedFiles.length > 0) {
                report += `## Exposed Files Found\n\n`;
                findings.exposedFiles.forEach(file => {
                    report += `- ⚠️ ${file}\n`;
                });
                report += `\n`;
            }

            if (findings.secrets.length > 0) {
                report += `## Potential Secrets Found\n\n`;
                findings.secrets.forEach(secret => {
                    report += `- ⚠️ ${secret}\n`;
                });
                report += `\n`;
            }
        } else {
            const repos = await this.listRepositories();
            report += `## Repositories Found: ${repos.length}\n\n`;
            repos.slice(0, 10).forEach(repo => {
                report += `- ${repo.name} (${repo.visibility || 'public'})\n`;
            });
            report += `\n`;
        }

        report += `## Recommendations\n\n`;
        report += `1. Review exposed files and remove sensitive information\n`;
        report += `2. Use environment variables for secrets\n`;
        report += `3. Add sensitive files to .gitignore\n`;
        report += `4. Rotate any exposed credentials\n`;
        report += `5. Enable secret scanning in GitHub\n\n`;

        return report;
    }
}

// Main execution
async function main() {
    if (process.argv.length < 3) {
        console.log('Usage: node github_repository_analyzer.js <owner> [repo]');
        console.log('Example: node github_repository_analyzer.js octocat');
        console.log('Example: node github_repository_analyzer.js octocat Hello-World');
        process.exit(1);
    }

    const owner = process.argv[2];
    const repo = process.argv[3] || null;

    const analyzer = new GitHubRepositoryAnalyzer(owner, repo);

    const report = await analyzer.generateReport();

    let filename = `github_analysis_${owner}`;
    if (repo) {
        filename += `_${repo}`;
    }
    filename += '.md';

    fs.writeFileSync(filename, report, 'utf8');

    console.log(`[+] GitHub analysis complete`);
    console.log(`[+] Report saved to ${filename}`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = GitHubRepositoryAnalyzer;

