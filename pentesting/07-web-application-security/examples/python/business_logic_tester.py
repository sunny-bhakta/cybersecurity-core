#!/usr/bin/env python3
"""
Business Logic Vulnerability Tester
Tests for business logic flaws in web applications.
"""

import sys
import requests
from typing import List, Dict

class BusinessLogicTester:
    def __init__(self, base_url: str):
        self.base_url = base_url
        self.vulnerabilities = []
    
    def test_price_manipulation(self, endpoint: str, params: Dict) -> bool:
        """Test for price manipulation vulnerabilities"""
        print(f"[*] Testing price manipulation on {endpoint}...")
        
        # Try to modify price in request
        test_params = params.copy()
        original_price = test_params.get('price', 0)
        
        # Try negative price
        test_params['price'] = -1
        response = requests.post(f"{self.base_url}{endpoint}", json=test_params, timeout=10)
        if response.status_code == 200:
            print("[!] Application accepts negative prices!")
            self.vulnerabilities.append("Price manipulation: Negative prices accepted")
            return True
        
        # Try zero price
        test_params['price'] = 0
        response = requests.post(f"{self.base_url}{endpoint}", json=test_params, timeout=10)
        if response.status_code == 200:
            print("[!] Application accepts zero prices!")
            self.vulnerabilities.append("Price manipulation: Zero prices accepted")
            return True
        
        return False
    
    def test_quantity_manipulation(self, endpoint: str, params: Dict) -> bool:
        """Test for quantity manipulation"""
        print(f"[*] Testing quantity manipulation on {endpoint}...")
        
        test_params = params.copy()
        
        # Try negative quantity
        test_params['quantity'] = -1
        response = requests.post(f"{self.base_url}{endpoint}", json=test_params, timeout=10)
        if response.status_code == 200:
            print("[!] Application accepts negative quantities!")
            self.vulnerabilities.append("Quantity manipulation: Negative quantities accepted")
            return True
        
        # Try extremely large quantity
        test_params['quantity'] = 999999999
        response = requests.post(f"{self.base_url}{endpoint}", json=test_params, timeout=10)
        if response.status_code == 200:
            print("[!] Application accepts extremely large quantities!")
            self.vulnerabilities.append("Quantity manipulation: No upper limit validation")
            return True
        
        return False
    
    def test_workflow_bypass(self, endpoint: str) -> bool:
        """Test for workflow bypass vulnerabilities"""
        print(f"[*] Testing workflow bypass on {endpoint}...")
        
        # Try to skip steps in multi-step process
        # Example: Skip payment step and go directly to confirmation
        skip_steps = ['/checkout/confirm', '/order/complete']
        
        for step in skip_steps:
            try:
                response = requests.get(f"{self.base_url}{step}", timeout=10)
                if response.status_code == 200:
                    print(f"[!] Workflow step {step} accessible without prerequisites!")
                    self.vulnerabilities.append(f"Workflow bypass: {step} accessible")
                    return True
            except:
                pass
        
        return False
    
    def test_race_condition(self, endpoint: str, params: Dict) -> bool:
        """Test for race condition vulnerabilities"""
        print(f"[*] Testing race conditions on {endpoint}...")
        
        import threading
        
        results = []
        
        def make_request():
            try:
                response = requests.post(f"{self.base_url}{endpoint}", json=params, timeout=10)
                results.append(response.status_code)
            except:
                pass
        
        # Send multiple simultaneous requests
        threads = []
        for _ in range(10):
            t = threading.Thread(target=make_request)
            threads.append(t)
            t.start()
        
        for t in threads:
            t.join()
        
        # Check if multiple requests succeeded when only one should
        if len([r for r in results if r == 200]) > 1:
            print("[!] Race condition detected!")
            self.vulnerabilities.append("Race condition: Multiple concurrent requests succeed")
            return True
        
        return False
    
    def test_authorization_bypass(self, endpoint: str, user_id: int) -> bool:
        """Test for authorization bypass (IDOR)"""
        print(f"[*] Testing authorization bypass on {endpoint}...")
        
        # Try to access another user's resource
        test_endpoint = f"{endpoint}/{user_id + 1}"
        
        try:
            response = requests.get(f"{self.base_url}{test_endpoint}", timeout=10)
            if response.status_code == 200:
                print(f"[!] Authorization bypass: Can access user {user_id + 1}'s data!")
                self.vulnerabilities.append(f"Authorization bypass: IDOR vulnerability")
                return True
        except:
            pass
        
        return False
    
    def generate_report(self) -> str:
        """Generate business logic test report"""
        report = f"# Business Logic Vulnerability Test Report\n\n"
        report += f"**Target**: {self.base_url}\n\n"
        
        if self.vulnerabilities:
            report += "## Vulnerabilities Found\n\n"
            report += "⚠️ **WARNING**: Business logic vulnerabilities detected!\n\n"
            for i, vuln in enumerate(self.vulnerabilities, 1):
                report += f"{i}. {vuln}\n"
            report += "\n"
        else:
            report += "✅ No obvious business logic vulnerabilities detected.\n\n"
        
        report += "## Common Business Logic Vulnerabilities\n\n"
        report += "1. **Price Manipulation**: Modifying prices in requests\n"
        report += "2. **Quantity Manipulation**: Bypassing quantity limits\n"
        report += "3. **Workflow Bypass**: Skipping required steps\n"
        report += "4. **Race Conditions**: Concurrent request handling issues\n"
        report += "5. **Authorization Bypass**: Accessing unauthorized resources\n"
        report += "6. **Time-based Attacks**: Exploiting time-sensitive operations\n\n"
        
        report += "## Recommendations\n\n"
        report += "1. Validate all business logic on server-side\n"
        report += "2. Implement proper state management\n"
        report += "3. Use transactions for critical operations\n"
        report += "4. Implement rate limiting\n"
        report += "5. Add proper authorization checks\n\n"
        
        return report

def main():
    if len(sys.argv) < 2:
        print("Usage: python business_logic_tester.py <base_url>")
        print("Example: python business_logic_tester.py http://example.com")
        sys.exit(1)
    
    base_url = sys.argv[1]
    
    tester = BusinessLogicTester(base_url)
    
    # Example test cases
    # tester.test_price_manipulation("/api/checkout", {"price": 100, "item": "test"})
    # tester.test_workflow_bypass("/checkout")
    
    report = tester.generate_report()
    
    filename = "business_logic_test_report.md"
    with open(filename, 'w') as f:
        f.write(report)
    
    print(f"[+] Business logic testing complete")
    print(f"[+] Report saved to {filename}")
    print(f"[!] WARNING: Only test applications you own or have permission to test!")

if __name__ == '__main__':
    main()

