#!/usr/bin/env python3
"""
OAuth Vulnerability Tester
Tests for OAuth 2.0 and OpenID Connect vulnerabilities.
"""

import sys
import requests
from typing import Dict, List

class OAuthTester:
    def __init__(self, base_url: str):
        self.base_url = base_url
        self.vulnerabilities = []
    
    def test_redirect_uri_validation(self, auth_endpoint: str, client_id: str) -> bool:
        """Test for redirect URI validation bypass"""
        print(f"[*] Testing redirect URI validation on {auth_endpoint}...")
        
        # Try various redirect URI bypass techniques
        test_redirects = [
            'http://evil.com',
            'https://evil.com',
            'http://localhost',
            'http://127.0.0.1',
            'javascript:alert(1)',
            '//evil.com',
            f'http://{self.base_url.split("//")[1]}.evil.com' if '//' in self.base_url else 'http://evil.com'
        ]
        
        vulnerable = False
        
        for redirect_uri in test_redirects:
            params = {
                'response_type': 'code',
                'client_id': client_id,
                'redirect_uri': redirect_uri,
                'scope': 'openid profile',
                'state': 'test'
            }
            
            try:
                response = requests.get(auth_endpoint, params=params, timeout=10, allow_redirects=False)
                
                # Check if redirect was accepted
                if response.status_code in [302, 301, 307, 308]:
                    location = response.headers.get('Location', '')
                    if redirect_uri in location or 'evil.com' in location:
                        print(f"[!] Redirect URI validation bypass: {redirect_uri} accepted!")
                        self.vulnerabilities.append(f"Redirect URI validation: {redirect_uri} accepted")
                        vulnerable = True
            except:
                pass
        
        return vulnerable
    
    def test_client_secret_exposure(self, token_endpoint: str) -> bool:
        """Test for client secret exposure"""
        print(f"[*] Testing client secret exposure...")
        
        # Check if client secret is exposed in client-side code
        # In real implementation, would analyze JavaScript files
        # This is a simplified example
        
        return False
    
    def test_state_parameter(self, auth_endpoint: str, client_id: str) -> bool:
        """Test for missing or weak state parameter"""
        print(f"[*] Testing state parameter...")
        
        # Test without state parameter
        params = {
            'response_type': 'code',
            'client_id': client_id,
            'redirect_uri': 'http://localhost/callback'
        }
        
        try:
            response = requests.get(auth_endpoint, params=params, timeout=10)
            if response.status_code == 200:
                print("[!] State parameter missing or not validated!")
                self.vulnerabilities.append("State parameter: Missing or not validated")
                return True
        except:
            pass
        
        return False
    
    def test_scope_manipulation(self, auth_endpoint: str, client_id: str) -> bool:
        """Test for scope manipulation"""
        print(f"[*] Testing scope manipulation...")
        
        # Try to request additional scopes
        test_scopes = [
            'admin',
            'read:all',
            'write:all',
            'delete:all',
            '*'
        ]
        
        for scope in test_scopes:
            params = {
                'response_type': 'code',
                'client_id': client_id,
                'redirect_uri': 'http://localhost/callback',
                'scope': f'openid profile {scope}'
            }
            
            try:
                response = requests.get(auth_endpoint, params=params, timeout=10)
                if response.status_code == 200:
                    # Check if additional scope was granted
                    # In real implementation, would check token response
                    print(f"[!] Scope manipulation: Additional scope '{scope}' may be granted")
                    self.vulnerabilities.append(f"Scope manipulation: {scope} may be granted")
                    return True
            except:
                pass
        
        return False
    
    def test_code_replay(self, token_endpoint: str, code: str, client_id: str) -> bool:
        """Test for authorization code replay"""
        print(f"[*] Testing authorization code replay...")
        
        # Try to use same code multiple times
        data = {
            'grant_type': 'authorization_code',
            'code': code,
            'client_id': client_id,
            'redirect_uri': 'http://localhost/callback'
        }
        
        try:
            response1 = requests.post(token_endpoint, data=data, timeout=10)
            if response1.status_code == 200:
                # Try to use same code again
                response2 = requests.post(token_endpoint, data=data, timeout=10)
                if response2.status_code == 200:
                    print("[!] Authorization code can be reused!")
                    self.vulnerabilities.append("Code replay: Authorization code can be reused")
                    return True
        except:
            pass
        
        return False
    
    def generate_report(self) -> str:
        """Generate OAuth test report"""
        report = f"# OAuth Vulnerability Test Report\n\n"
        report += f"**Target**: {self.base_url}\n\n"
        
        if self.vulnerabilities:
            report += "## Vulnerabilities Found\n\n"
            report += "⚠️ **WARNING**: OAuth vulnerabilities detected!\n\n"
            for i, vuln in enumerate(self.vulnerabilities, 1):
                report += f"{i}. {vuln}\n"
            report += "\n"
        else:
            report += "✅ No obvious OAuth vulnerabilities detected.\n\n"
        
        report += "## Common OAuth Vulnerabilities\n\n"
        report += "1. **Redirect URI Validation**: Weak or missing redirect URI validation\n"
        report += "2. **Client Secret Exposure**: Client secret in client-side code\n"
        report += "3. **State Parameter**: Missing or weak state parameter\n"
        report += "4. **Scope Manipulation**: Ability to request unauthorized scopes\n"
        report += "5. **Code Replay**: Authorization codes can be reused\n"
        report += "6. **PKCE Bypass**: Missing or weak PKCE implementation\n"
        report += "7. **Token Leakage**: Tokens exposed in URLs or logs\n\n"
        
        report += "## Recommendations\n\n"
        report += "1. Validate redirect URIs against whitelist\n"
        report += "2. Use PKCE for public clients\n"
        report += "3. Implement strong state parameter validation\n"
        report += "4. Limit scope requests to authorized scopes\n"
        report += "5. Make authorization codes single-use\n"
        report += "6. Use HTTPS for all OAuth endpoints\n"
        report += "7. Implement token expiration and rotation\n\n"
        
        return report

def main():
    if len(sys.argv) < 2:
        print("Usage: python oauth_tester.py <base_url>")
        print("Example: python oauth_tester.py http://example.com")
        sys.exit(1)
    
    base_url = sys.argv[1]
    
    tester = OAuthTester(base_url)
    
    # Example test cases
    # tester.test_redirect_uri_validation(f"{base_url}/oauth/authorize", "client123")
    # tester.test_state_parameter(f"{base_url}/oauth/authorize", "client123")
    
    report = tester.generate_report()
    
    filename = "oauth_test_report.md"
    with open(filename, 'w') as f:
        f.write(report)
    
    print(f"[+] OAuth testing complete")
    print(f"[+] Report saved to {filename}")
    print(f"[!] WARNING: Only test applications you own or have permission to test!")

if __name__ == '__main__':
    main()

