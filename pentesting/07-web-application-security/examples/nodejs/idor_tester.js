/**
 * IDOR (Insecure Direct Object Reference) / BOLA Tester
 * Tests for broken object level authorization vulnerabilities.
 */

const https = require('https');
const http = require('http');
const { URL } = require('url');
const fs = require('fs');

class IDORTester {
    constructor(baseUrl) {
        this.baseUrl = baseUrl;
        this.vulnerabilities = [];
    }

    async makeRequest(url, headers = {}) {
        return new Promise((resolve, reject) => {
            const urlObj = new URL(url);
            const protocol = urlObj.protocol === 'https:' ? https : http;

            const options = {
                hostname: urlObj.hostname,
                port: urlObj.port || (urlObj.protocol === 'https:' ? 443 : 80),
                path: urlObj.pathname + urlObj.search,
                method: 'GET',
                headers: headers,
                timeout: 5000
            };

            const req = protocol.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => { data += chunk; });
                res.on('end', () => {
                    resolve({
                        statusCode: res.statusCode,
                        text: data,
                        length: data.length
                    });
                });
            });

            req.on('error', reject);
            req.on('timeout', () => {
                req.destroy();
                reject(new Error('Timeout'));
            });

            req.end();
        });
    }

    async testSequentialIds(endpoint, paramName, startId = 1, endId = 100, authToken = null) {
        console.log(`[*] Testing sequential ID enumeration on ${endpoint}`);
        console.log(`[*] Testing IDs from ${startId} to ${endId}`);

        const vulnerableIds = [];
        const headers = {};
        if (authToken) {
            headers['Authorization'] = `Bearer ${authToken}`;
        }

        for (let testId = startId; testId <= endId; testId++) {
            try {
                const testUrl = endpoint.replace(paramName, testId);
                const response = await this.makeRequest(testUrl, headers);

                if (response.statusCode === 200 && response.length > 100) {
                    console.log(`[+] Found accessible resource with ID: ${testId}`);
                    vulnerableIds.push({
                        id: testId,
                        url: testUrl,
                        status_code: response.statusCode,
                        response_length: response.length
                    });
                }
            } catch (error) {
                // Continue to next ID
            }
        }

        return vulnerableIds;
    }

    async testHorizontalPrivilegeEscalation(endpoint, paramName, user1Id, user2Id, user1Token) {
        console.log(`[*] Testing horizontal privilege escalation`);

        const headers = { 'Authorization': `Bearer ${user1Token}` };
        const testUrl = endpoint.replace(paramName, user2Id);

        try {
            const response = await this.makeRequest(testUrl, headers);

            if (response.statusCode === 200) {
                console.log(`[+] VULNERABLE: Can access user ${user2Id}'s data with user ${user1Id}'s token`);
                return true;
            } else if (response.statusCode === 403) {
                console.log(`[-] Protected: Cannot access user ${user2Id}'s data (403 Forbidden)`);
                return false;
            }
        } catch (error) {
            console.log(`[-] Error: ${error.message}`);
        }

        return false;
    }

    async testVerticalPrivilegeEscalation(endpoint, paramName, adminId, userToken) {
        console.log(`[*] Testing vertical privilege escalation`);

        const headers = { 'Authorization': `Bearer ${userToken}` };
        const testUrl = endpoint.replace(paramName, adminId);

        try {
            const response = await this.makeRequest(testUrl, headers);

            if (response.statusCode === 200) {
                console.log(`[+] VULNERABLE: User can access admin resource ${adminId}`);
                return true;
            }
        } catch (error) {
            console.log(`[-] Error: ${error.message}`);
        }

        return false;
    }

    generateReport() {
        let report = `# IDOR / BOLA Test Report\n\n`;
        report += `**Target**: ${this.baseUrl}\n\n`;
        report += `## Summary\n\n`;
        report += `Total Vulnerabilities Found: ${this.vulnerabilities.length}\n\n`;

        report += `## Vulnerabilities\n\n`;
        this.vulnerabilities.forEach((vuln, i) => {
            report += `### ${i + 1}. ${vuln.type || 'Unknown'}\n\n`;
            report += `- **Endpoint**: ${vuln.endpoint || 'N/A'}\n`;
            report += `- **Parameter**: ${vuln.parameter || 'N/A'}\n`;
            report += `- **Description**: ${vuln.description || 'N/A'}\n\n`;
        });

        return report;
    }
}

async function main() {
    const args = process.argv.slice(2);
    if (args.length < 1) {
        console.log('Usage: node idor_tester.js <base_url>');
        console.log('Example: node idor_tester.js http://example.com/api/users');
        process.exit(1);
    }

    const baseUrl = args[0];
    const tester = new IDORTester(baseUrl);

    // Example: Test sequential ID enumeration
    const endpoint = `${baseUrl}/{id}`;
    const results = await tester.testSequentialIds(endpoint, '{id}', 1, 10);

    if (results.length > 0) {
        console.log(`\n[+] Found ${results.length} accessible resources`);
        results.forEach(result => {
            console.log(`    ID ${result.id}: ${result.url}`);
        });
    }

    const report = tester.generateReport();
    fs.writeFileSync('idor_test_report.md', report, 'utf8');

    console.log(`\n[+] Report saved to idor_test_report.md`);
    console.log(`[!] WARNING: Only test on systems you own or have permission to test!`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = IDORTester;

