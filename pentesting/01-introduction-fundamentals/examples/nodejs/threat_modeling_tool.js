#!/usr/bin/env node
/**
 * Threat Modeling Tool
 * Helps identify and document security threats using STRIDE methodology.
 */

const fs = require('fs');

const ThreatCategory = {
    SPOOFING: 'Spoofing',
    TAMPERING: 'Tampering',
    REPUDIATION: 'Repudiation',
    INFORMATION_DISCLOSURE: 'Information Disclosure',
    DENIAL_OF_SERVICE: 'Denial of Service',
    ELEVATION_OF_PRIVILEGE: 'Elevation of Privilege'
};

class ThreatModelingTool {
    constructor(systemName) {
        this.systemName = systemName;
        this.threats = [];
        this.assets = [];
        this.trustBoundaries = [];
    }

    addAsset(assetName, description, sensitivity = 'Medium') {
        this.assets.push({
            name: assetName,
            description: description,
            sensitivity: sensitivity
        });
    }

    addTrustBoundary(boundaryName, description) {
        this.trustBoundaries.push({
            name: boundaryName,
            description: description
        });
    }

    identifyThreat(category, asset, description, severity = 'Medium', mitigation = '') {
        this.threats.push({
            category: category,
            asset: asset,
            description: description,
            severity: severity,
            mitigation: mitigation
        });
    }

    generateThreatModel() {
        const date = new Date().toISOString().split('T')[0];
        
        let doc = `# Threat Model: ${this.systemName}

## System Overview

**System Name**: ${this.systemName}
**Threat Model Date**: ${date}

---

## Assets

The following assets have been identified:

`;

        this.assets.forEach((asset, i) => {
            doc += `### ${i + 1}. ${asset.name}\n\n`;
            doc += `**Description**: ${asset.description}\n\n`;
            doc += `**Sensitivity**: ${asset.sensitivity}\n\n`;
        });

        doc += `\n---\n\n## Trust Boundaries\n\n`;
        doc += `The following trust boundaries have been identified:\n\n`;

        this.trustBoundaries.forEach((boundary, i) => {
            doc += `${i + 1}. **${boundary.name}**: ${boundary.description}\n`;
        });

        doc += `\n---\n\n## Threat Analysis (STRIDE)\n\n`;
        doc += `### STRIDE Methodology\n\n`;
        doc += `- **S**poofing: Impersonating something or someone\n`;
        doc += `- **T**ampering: Modifying data or code\n`;
        doc += `- **R**epudiation: Denying an action occurred\n`;
        doc += `- **I**nformation Disclosure: Exposing information to unauthorized parties\n`;
        doc += `- **D**enial of Service: Disrupting service availability\n`;
        doc += `- **E**levation of Privilege: Gaining unauthorized access\n\n`;

        doc += `### Identified Threats\n\n`;

        // Group threats by category
        const threatsByCategory = {};
        this.threats.forEach(threat => {
            if (!threatsByCategory[threat.category]) {
                threatsByCategory[threat.category] = [];
            }
            threatsByCategory[threat.category].push(threat);
        });

        Object.values(ThreatCategory).forEach(category => {
            if (threatsByCategory[category]) {
                doc += `#### ${category}\n\n`;
                threatsByCategory[category].forEach(threat => {
                    doc += `**Asset**: ${threat.asset}\n\n`;
                    doc += `**Threat**: ${threat.description}\n\n`;
                    doc += `**Severity**: ${threat.severity}\n\n`;
                    if (threat.mitigation) {
                        doc += `**Mitigation**: ${threat.mitigation}\n\n`;
                    }
                    doc += `---\n\n`;
                });
            }
        });

        doc += `\n## Risk Summary\n\n`;

        // Count threats by severity
        const severityCount = { Critical: 0, High: 0, Medium: 0, Low: 0 };
        this.threats.forEach(threat => {
            if (severityCount[threat.severity] !== undefined) {
                severityCount[threat.severity]++;
            }
        });

        doc += `| Severity | Count |\n`;
        doc += `|----------|-------|\n`;
        Object.entries(severityCount).forEach(([severity, count]) => {
            doc += `| ${severity} | ${count} |\n`;
        });

        doc += `\n---\n\n## Recommendations\n\n`;
        doc += `1. Prioritize mitigation of Critical and High severity threats\n`;
        doc += `2. Implement security controls at trust boundaries\n`;
        doc += `3. Regularly review and update threat model\n`;
        doc += `4. Integrate threat modeling into SDLC\n\n`;

        return doc;
    }

    autoIdentifyThreats() {
        this.assets.forEach(asset => {
            const assetName = asset.name.toLowerCase();

            // Identify common threats based on asset type
            if (assetName.includes('database') || assetName.includes('db')) {
                this.identifyThreat(
                    ThreatCategory.INFORMATION_DISCLOSURE,
                    asset.name,
                    'Unauthorized access to database could expose sensitive data',
                    'High',
                    'Implement database encryption, access controls, and auditing'
                );
                this.identifyThreat(
                    ThreatCategory.TAMPERING,
                    asset.name,
                    'Unauthorized modification of database records',
                    'High',
                    'Implement database integrity checks and access controls'
                );
            }

            if (assetName.includes('api') || assetName.includes('endpoint')) {
                this.identifyThreat(
                    ThreatCategory.SPOOFING,
                    asset.name,
                    'API authentication bypass or token spoofing',
                    'High',
                    'Implement strong authentication and authorization mechanisms'
                );
                this.identifyThreat(
                    ThreatCategory.DENIAL_OF_SERVICE,
                    asset.name,
                    'API endpoint could be overwhelmed with requests',
                    'Medium',
                    'Implement rate limiting and request throttling'
                );
            }

            if (assetName.includes('web') || assetName.includes('application')) {
                this.identifyThreat(
                    ThreatCategory.ELEVATION_OF_PRIVILEGE,
                    asset.name,
                    'Privilege escalation through application vulnerabilities',
                    'High',
                    'Implement proper authorization checks and least privilege'
                );
                this.identifyThreat(
                    ThreatCategory.INFORMATION_DISCLOSURE,
                    asset.name,
                    'Sensitive information exposure through application',
                    'Medium',
                    'Implement proper input validation and output encoding'
                );
            }
        });
    }
}

// Main execution
function main() {
    console.log('Threat Modeling Tool');
    console.log('='.repeat(50));

    const tool = new ThreatModelingTool('Example Web Application');

    // Add assets
    tool.addAsset('Web Application', 'Main web application server', 'High');
    tool.addAsset('Database', 'PostgreSQL database containing user data', 'Critical');
    tool.addAsset('API Server', 'RESTful API endpoints', 'High');
    tool.addAsset('Authentication Service', 'OAuth 2.0 authentication service', 'Critical');

    // Add trust boundaries
    tool.addTrustBoundary('Internet to DMZ', 'External users accessing web application');
    tool.addTrustBoundary('DMZ to Internal Network', 'Web server accessing database');

    // Auto-identify threats
    tool.autoIdentifyThreats();

    // Add custom threats
    tool.identifyThreat(
        ThreatCategory.REPUDIATION,
        'Authentication Service',
        'User could deny performing sensitive actions',
        'Medium',
        'Implement comprehensive audit logging'
    );

    // Generate threat model
    const document = tool.generateThreatModel();

    // Save to file
    const filename = 'threat_model.md';
    fs.writeFileSync(filename, document, 'utf8');

    console.log(`[+] Threat model generated`);
    console.log(`[+] Saved to: ${filename}`);
    console.log(`[+] Identified ${tool.threats.length} threats`);
}

if (require.main === module) {
    main();
}

module.exports = { ThreatModelingTool, ThreatCategory };

