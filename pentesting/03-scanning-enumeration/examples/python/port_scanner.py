#!/usr/bin/env python3
"""
Port Scanner
Scans target hosts for open ports using various scanning techniques.
"""

import socket
import sys
import threading
from typing import List, Dict
from concurrent.futures import ThreadPoolExecutor, as_completed

class PortScanner:
    def __init__(self, target: str, timeout: float = 1.0):
        self.target = target
        self.timeout = timeout
        self.open_ports = []
        self.scan_results = []
    
    def tcp_connect_scan(self, port: int) -> Dict:
        """TCP Connect Scan - Full TCP handshake"""
        result = {
            'port': port,
            'state': 'closed',
            'service': 'unknown'
        }
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            result_code = sock.connect_ex((self.target, port))
            sock.close()
            
            if result_code == 0:
                result['state'] = 'open'
                # Try to grab banner
                try:
                    service = self.grab_banner(port)
                    result['service'] = service
                except:
                    pass
                self.open_ports.append(port)
        except Exception as e:
            result['error'] = str(e)
        
        return result
    
    def tcp_syn_scan(self, port: int) -> Dict:
        """TCP SYN Scan - Half-open connection (requires root on Linux)"""
        # Note: This is a simplified version
        # Full SYN scan requires raw sockets (root privileges)
        # This falls back to connect scan
        return self.tcp_connect_scan(port)
    
    def grab_banner(self, port: int) -> str:
        """Attempt to grab service banner"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            sock.connect((self.target, port))
            
            # Send a simple request for common services
            if port == 80:
                sock.send(b'GET / HTTP/1.1\r\nHost: ' + self.target.encode() + b'\r\n\r\n')
            elif port == 22:
                pass  # SSH doesn't respond to simple requests
            elif port == 21:
                sock.send(b'QUIT\r\n')
            
            banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
            sock.close()
            return banner[:100]  # Limit banner length
        except:
            return 'unknown'
    
    def scan_port_range(self, start_port: int, end_port: int, 
                       scan_type: str = 'connect', threads: int = 100) -> List[Dict]:
        """Scan a range of ports"""
        print(f"[*] Scanning {self.target} ports {start_port}-{end_port} ({scan_type} scan)")
        
        ports = range(start_port, end_port + 1)
        results = []
        
        with ThreadPoolExecutor(max_workers=threads) as executor:
            if scan_type == 'syn':
                futures = {executor.submit(self.tcp_syn_scan, port): port for port in ports}
            else:
                futures = {executor.submit(self.tcp_connect_scan, port): port for port in ports}
            
            for future in as_completed(futures):
                result = future.result()
                results.append(result)
                if result['state'] == 'open':
                    print(f"[+] Port {result['port']} is open - {result['service']}")
        
        self.scan_results = sorted(results, key=lambda x: x['port'])
        return self.scan_results
    
    def scan_common_ports(self, scan_type: str = 'connect') -> List[Dict]:
        """Scan common ports"""
        common_ports = [
            21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 445,
            993, 995, 1723, 3306, 3389, 5900, 8080
        ]
        
        print(f"[*] Scanning common ports on {self.target}")
        results = []
        
        with ThreadPoolExecutor(max_workers=50) as executor:
            if scan_type == 'syn':
                futures = {executor.submit(self.tcp_syn_scan, port): port for port in common_ports}
            else:
                futures = {executor.submit(self.tcp_connect_scan, port): port for port in common_ports}
            
            for future in as_completed(futures):
                result = future.result()
                results.append(result)
                if result['state'] == 'open':
                    print(f"[+] Port {result['port']} is open - {result['service']}")
        
        self.scan_results = sorted(results, key=lambda x: x['port'])
        return self.scan_results
    
    def generate_report(self) -> str:
        """Generate scan report"""
        report = f"# Port Scan Report\n\n"
        report += f"**Target**: {self.target}\n\n"
        report += f"## Summary\n\n"
        report += f"Total Ports Scanned: {len(self.scan_results)}\n"
        report += f"Open Ports: {len(self.open_ports)}\n\n"
        
        report += "## Open Ports\n\n"
        for result in self.scan_results:
            if result['state'] == 'open':
                report += f"### Port {result['port']}\n\n"
                report += f"- **State**: {result['state']}\n"
                report += f"- **Service**: {result['service']}\n\n"
        
        return report

def main():
    if len(sys.argv) < 2:
        print("Usage: python port_scanner.py <target> [start_port] [end_port]")
        print("Example: python port_scanner.py 192.168.1.1 1 1000")
        sys.exit(1)
    
    target = sys.argv[1]
    scanner = PortScanner(target)
    
    if len(sys.argv) == 2:
        # Scan common ports
        results = scanner.scan_common_ports()
    elif len(sys.argv) == 4:
        start_port = int(sys.argv[2])
        end_port = int(sys.argv[3])
        results = scanner.scan_port_range(start_port, end_port)
    else:
        print("Invalid arguments")
        sys.exit(1)
    
    # Generate report
    report = scanner.generate_report()
    with open(f'port_scan_{target.replace(".", "_")}.md', 'w') as f:
        f.write(report)
    
    print(f"\n[+] Scan complete. Found {len(scanner.open_ports)} open ports")
    print(f"[+] Report saved to port_scan_{target.replace('.', '_')}.md")
    print(f"[!] WARNING: Only scan systems you own or have permission to scan!")

if __name__ == '__main__':
    main()

