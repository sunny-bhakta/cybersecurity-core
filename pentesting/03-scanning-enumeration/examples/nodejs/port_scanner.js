/**
 * Port Scanner
 * Scans target hosts for open ports using TCP connect scan.
 */

const net = require('net');
const { promisify } = require('util');
const fs = require('fs');

class PortScanner {
    constructor(target, timeout = 1000) {
        this.target = target;
        this.timeout = timeout;
        this.openPorts = [];
        this.scanResults = [];
    }

    async tcpConnectScan(port) {
        const result = {
            port: port,
            state: 'closed',
            service: 'unknown'
        };

        return new Promise((resolve) => {
            const socket = new net.Socket();
            socket.setTimeout(this.timeout);

            socket.on('connect', () => {
                result.state = 'open';
                this.openPorts.push(port);
                
                // Try to grab banner
                this.grabBanner(port).then(banner => {
                    result.service = banner;
                    socket.destroy();
                    resolve(result);
                }).catch(() => {
                    socket.destroy();
                    resolve(result);
                });
            });

            socket.on('timeout', () => {
                socket.destroy();
                resolve(result);
            });

            socket.on('error', () => {
                socket.destroy();
                resolve(result);
            });

            socket.connect(port, this.target);
        });
    }

    async grabBanner(port) {
        return new Promise((resolve, reject) => {
            const socket = new net.Socket();
            socket.setTimeout(2000);

            socket.on('connect', () => {
                // Send a simple request for common services
                if (port === 80) {
                    socket.write(`GET / HTTP/1.1\r\nHost: ${this.target}\r\n\r\n`);
                } else if (port === 21) {
                    socket.write('QUIT\r\n');
                }

                socket.on('data', (data) => {
                    const banner = data.toString('utf-8').substring(0, 100);
                    socket.destroy();
                    resolve(banner.trim());
                });

                socket.on('timeout', () => {
                    socket.destroy();
                    resolve('unknown');
                });
            });

            socket.on('error', () => {
                resolve('unknown');
            });

            socket.connect(port, this.target);
        });
    }

    async scanPortRange(startPort, endPort, threads = 50) {
        console.log(`[*] Scanning ${this.target} ports ${startPort}-${endPort}`);

        const ports = [];
        for (let i = startPort; i <= endPort; i++) {
            ports.push(i);
        }

        // Process in batches to limit concurrent connections
        const batchSize = threads;
        const results = [];

        for (let i = 0; i < ports.length; i += batchSize) {
            const batch = ports.slice(i, i + batchSize);
            const batchResults = await Promise.all(
                batch.map(port => this.tcpConnectScan(port))
            );

            batchResults.forEach(result => {
                results.push(result);
                if (result.state === 'open') {
                    console.log(`[+] Port ${result.port} is open - ${result.service}`);
                }
            });
        }

        this.scanResults = results.sort((a, b) => a.port - b.port);
        return this.scanResults;
    }

    async scanCommonPorts() {
        const commonPorts = [
            21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 445,
            993, 995, 1723, 3306, 3389, 5900, 8080
        ];

        console.log(`[*] Scanning common ports on ${this.target}`);
        const results = await Promise.all(
            commonPorts.map(port => this.tcpConnectScan(port))
        );

        results.forEach(result => {
            if (result.state === 'open') {
                console.log(`[+] Port ${result.port} is open - ${result.service}`);
            }
        });

        this.scanResults = results.sort((a, b) => a.port - b.port);
        return this.scanResults;
    }

    generateReport() {
        let report = `# Port Scan Report\n\n`;
        report += `**Target**: ${this.target}\n\n`;
        report += `## Summary\n\n`;
        report += `Total Ports Scanned: ${this.scanResults.length}\n`;
        report += `Open Ports: ${this.openPorts.length}\n\n`;

        report += `## Open Ports\n\n`;
        this.scanResults.forEach(result => {
            if (result.state === 'open') {
                report += `### Port ${result.port}\n\n`;
                report += `- **State**: ${result.state}\n`;
                report += `- **Service**: ${result.service}\n\n`;
            }
        });

        return report;
    }
}

async function main() {
    const args = process.argv.slice(2);
    if (args.length < 1) {
        console.log('Usage: node port_scanner.js <target> [start_port] [end_port]');
        console.log('Example: node port_scanner.js 192.168.1.1 1 1000');
        process.exit(1);
    }

    const target = args[0];
    const scanner = new PortScanner(target);

    let results;
    if (args.length === 1) {
        // Scan common ports
        results = await scanner.scanCommonPorts();
    } else if (args.length === 3) {
        const startPort = parseInt(args[1]);
        const endPort = parseInt(args[2]);
        results = await scanner.scanPortRange(startPort, endPort);
    } else {
        console.log('Invalid arguments');
        process.exit(1);
    }

    // Generate report
    const report = scanner.generateReport();
    const filename = `port_scan_${target.replace(/\./g, '_')}.md`;
    fs.writeFileSync(filename, report, 'utf8');

    console.log(`\n[+] Scan complete. Found ${scanner.openPorts.length} open ports`);
    console.log(`[+] Report saved to ${filename}`);
    console.log(`[!] WARNING: Only scan systems you own or have permission to scan!`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = PortScanner;

