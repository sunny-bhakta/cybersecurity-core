#!/usr/bin/env node
/**
 * Service Version Detection Tool
 * Detects versions of services running on target systems (for scanning category).
 */

const net = require('net');
const https = require('https');
const http = require('http');
const fs = require('fs');

class ServiceVersionDetection {
    constructor(target, port) {
        this.target = target;
        this.port = port;
        this.versions = {};
    }

    async detectHttpVersion() {
        console.log(`[*] Detecting HTTP version on ${this.target}:${this.port}...`);
        
        const versionInfo = {
            server: 'Unknown',
            version: 'Unknown',
            poweredBy: 'Unknown'
        };
        
        try {
            const protocol = this.port === 443 ? https : http;
            const url = `${this.port === 443 ? 'https' : 'http'}://${this.target}:${this.port}`;
            
            await new Promise((resolve, reject) => {
                protocol.get(url, { timeout: 10000, rejectUnauthorized: false }, (res) => {
                    versionInfo.server = res.headers['server'] || 'Unknown';
                    versionInfo.poweredBy = res.headers['x-powered-by'] || 'Unknown';
                    
                    if (versionInfo.server && versionInfo.server !== 'Unknown') {
                        const parts = versionInfo.server.split('/');
                        if (parts.length > 1) {
                            versionInfo.version = parts[1];
                        }
                    }
                    
                    resolve();
                }).on('error', (err) => {
                    reject(err);
                });
            });
        } catch (err) {
            console.log(`[-] Error: ${err.message}`);
        }
        
        return versionInfo;
    }

    detectSshVersion() {
        return new Promise((resolve) => {
            console.log(`[*] Detecting SSH version on ${this.target}:${this.port}...`);
            
            const sock = new net.Socket();
            sock.setTimeout(5000);
            
            sock.on('connect', () => {
                let banner = '';
                sock.on('data', (data) => {
                    banner += data.toString('utf8');
                    sock.destroy();
                    resolve(banner.trim());
                });
            });
            
            sock.on('timeout', () => {
                sock.destroy();
                resolve('Unknown');
            });
            
            sock.on('error', () => {
                resolve('Unknown');
            });
            
            sock.connect(this.port, this.target);
        });
    }

    detectFtpVersion() {
        return new Promise((resolve) => {
            console.log(`[*] Detecting FTP version on ${this.target}:${this.port}...`);
            
            const sock = new net.Socket();
            sock.setTimeout(5000);
            
            sock.on('connect', () => {
                let banner = '';
                sock.on('data', (data) => {
                    banner += data.toString('utf8');
                    sock.destroy();
                    resolve(banner.trim());
                });
            });
            
            sock.on('timeout', () => {
                sock.destroy();
                resolve('Unknown');
            });
            
            sock.on('error', () => {
                resolve('Unknown');
            });
            
            sock.connect(this.port, this.target);
        });
    }

    detectSmtpVersion() {
        return new Promise((resolve) => {
            console.log(`[*] Detecting SMTP version on ${this.target}:${this.port}...`);
            
            const sock = new net.Socket();
            sock.setTimeout(5000);
            
            sock.on('connect', () => {
                let banner = '';
                sock.on('data', (data) => {
                    banner += data.toString('utf8');
                    sock.destroy();
                    resolve(banner.trim());
                });
            });
            
            sock.on('timeout', () => {
                sock.destroy();
                resolve('Unknown');
            });
            
            sock.on('error', () => {
                resolve('Unknown');
            });
            
            sock.connect(this.port, this.target);
        });
    }

    async detectAll() {
        console.log(`[*] Starting version detection for ${this.target}:${this.port}\n`);
        
        const results = {};
        
        try {
            if ([80, 443, 8080, 8443].includes(this.port)) {
                results.http = await this.detectHttpVersion();
            } else if (this.port === 22) {
                results.ssh = await this.detectSshVersion();
            } else if (this.port === 21) {
                results.ftp = await this.detectFtpVersion();
            } else if (this.port === 25) {
                results.smtp = await this.detectSmtpVersion();
            } else {
                // Generic banner grab
                try {
                    const sock = new net.Socket();
                    sock.setTimeout(5000);
                    
                    await new Promise((resolve) => {
                        sock.on('connect', () => {
                            let banner = '';
                            sock.on('data', (data) => {
                                banner += data.toString('utf8');
                                sock.destroy();
                                results.banner = banner.trim();
                                resolve();
                            });
                            
                            sock.on('timeout', () => {
                                sock.destroy();
                                resolve();
                            });
                            
                            sock.on('error', () => {
                                resolve();
                            });
                            
                            sock.connect(this.port, this.target);
                        });
                    });
                } catch (err) {
                    // Ignore errors
                }
            }
        } catch (err) {
            console.log(`[-] Error: ${err.message}`);
        }
        
        return results;
    }

    async generateReport() {
        const results = await this.detectAll();
        
        let report = `# Service Version Detection Report\n\n`;
        report += `**Target**: ${this.target}:${this.port}\n\n`;
        
        if (Object.keys(results).length > 0) {
            report += `## Detected Versions\n\n`;
            
            if (results.http) {
                report += `### HTTP Service\n\n`;
                report += `**Server**: ${results.http.server}\n\n`;
                report += `**Version**: ${results.http.version}\n\n`;
                report += `**X-Powered-By**: ${results.http.poweredBy}\n\n`;
            }
            
            if (results.ssh) {
                report += `### SSH Service\n\n`;
                report += `**Banner**: ${results.ssh}\n\n`;
            }
            
            if (results.ftp) {
                report += `### FTP Service\n\n`;
                report += `**Banner**: ${results.ftp}\n\n`;
            }
            
            if (results.smtp) {
                report += `### SMTP Service\n\n`;
                report += `**Banner**: ${results.smtp}\n\n`;
            }
            
            if (results.banner) {
                report += `### Service Banner\n\n`;
                report += `\`\`\`\n${results.banner}\n\`\`\`\n\n`;
            }
        } else {
            report += `[-] Could not detect service version.\n\n`;
        }
        
        report += `## Security Implications\n\n`;
        report += `1. **Outdated Versions**: May have known vulnerabilities\n`;
        report += `2. **Version Disclosure**: Reveals technology stack\n`;
        report += `3. **Targeted Attacks**: Attackers can target specific versions\n`;
        report += `4. **Patch Management**: Helps identify systems needing updates\n\n`;
        
        report += `## Recommendations\n\n`;
        report += `1. Keep services updated to latest versions\n`;
        report += `2. Consider hiding version information\n`;
        report += `3. Use security headers to limit information disclosure\n`;
        report += `4. Regularly scan for outdated software\n\n`;
        
        return report;
    }
}

async function main() {
    if (process.argv.length < 4) {
        console.log('Usage: node service_version_detection.js <target> <port>');
        console.log('Example: node service_version_detection.js 192.168.1.100 80');
        process.exit(1);
    }
    
    const target = process.argv[2];
    const port = parseInt(process.argv[3]);
    
    const detector = new ServiceVersionDetection(target, port);
    const report = await detector.generateReport();
    
    const filename = `version_detection_${target.replace(/\./g, '_')}_${port}.md`;
    fs.writeFileSync(filename, report, 'utf8');
    
    console.log(`\n[+] Version detection complete`);
    console.log(`[+] Report saved to ${filename}`);
    console.log(`[!] WARNING: Only scan systems you own or have permission to test!`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = ServiceVersionDetection;

