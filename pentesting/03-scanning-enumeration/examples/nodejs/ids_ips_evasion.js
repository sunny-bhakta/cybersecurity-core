#!/usr/bin/env node
/**
 * IDS/IPS Evasion Tool
 * Demonstrates techniques for evading Intrusion Detection/Prevention Systems.
 */

const fs = require('fs');

class IDSIPSEvasion {
    constructor(target, port) {
        this.target = target;
        this.port = port;
        this.techniques = [];
    }

    fragmentationEvasion(data) {
        console.log('[*] Using fragmentation evasion...');
        
        const fragmentSize = 8;
        const fragments = [];
        
        for (let i = 0; i < data.length; i += fragmentSize) {
            fragments.push(data.substring(i, i + fragmentSize));
        }
        
        this.techniques.push('Fragmentation');
        return fragments;
    }

    async timingEvasion(delay = 2000) {
        console.log(`[*] Using timing evasion (delay: ${delay}ms)...`);
        
        await new Promise(resolve => setTimeout(resolve, delay));
        this.techniques.push(`Timing (delay: ${delay}ms)`);
    }

    encodingEvasion(data) {
        console.log('[*] Using encoding evasion...');
        
        // URL encoding
        const encoded = data.replace(/ /g, '%20').replace(/\//g, '%2F');
        
        this.techniques.push('URL Encoding');
        return encoded;
    }

    caseVariation(data) {
        console.log('[*] Using case variation evasion...');
        
        // Mix case
        const varied = data.split('').map((c, i) => 
            i % 2 === 0 ? c.toUpperCase() : c.toLowerCase()
        ).join('');
        
        this.techniques.push('Case Variation');
        return varied;
    }

    nullByteInjection(data) {
        console.log('[*] Using null byte injection...');
        
        // Insert null bytes
        const modified = data.replace(/ /g, '\x00');
        
        this.techniques.push('Null Byte Injection');
        return modified;
    }

    async testEvasion(payload) {
        console.log(`[*] Testing IDS/IPS evasion techniques on ${this.target}:${this.port}...`);
        
        // Apply multiple evasion techniques
        const encoded = this.encodingEvasion(payload);
        const varied = this.caseVariation(encoded);
        const fragments = this.fragmentationEvasion(varied);
        
        // Use timing
        await this.timingEvasion(1500);
        
        return {
            original: payload,
            evaded: varied,
            fragments: fragments.length,
            techniques: this.techniques
        };
    }

    generateReport() {
        let report = `# IDS/IPS Evasion Report for ${this.target}:${this.port}\n\n`;
        
        report += `⚠️ **WARNING**: This tool is for authorized security testing only!\n\n`;
        
        report += `## Evasion Techniques Demonstrated\n\n`;
        
        const techniques = [
            '1. **Fragmentation**: Split packets to evade signature detection',
            '2. **Timing**: Use delays to avoid rate-based detection',
            '3. **Encoding**: Use various encodings (URL, Unicode, etc.)',
            '4. **Case Variation**: Mix upper/lower case to evade signatures',
            '5. **Null Byte Injection**: Insert null bytes in payloads',
            '6. **Protocol Tunneling**: Tunnel traffic through allowed protocols',
            '7. **Traffic Normalization**: Normalize traffic to bypass filters',
            '8. **Polymorphic Shellcode**: Use polymorphic techniques'
        ];
        
        techniques.forEach(technique => {
            report += `${technique}\n`;
        });
        report += `\n`;
        
        if (this.techniques.length > 0) {
            report += `## Techniques Used\n\n`;
            this.techniques.forEach(technique => {
                report += `- ${technique}\n`;
            });
            report += `\n`;
        }
        
        report += `## Detection Methods\n\n`;
        report += `1. **Deep Packet Inspection**: Analyze packet contents\n`;
        report += `2. **Behavioral Analysis**: Monitor for unusual patterns\n`;
        report += `3. **Anomaly Detection**: Detect deviations from normal traffic\n`;
        report += `4. **Multi-layered Defense**: Use multiple detection methods\n`;
        report += `5. **Regular Updates**: Keep signatures and rules updated\n\n`;
        
        report += `## Legal and Ethical Considerations\n\n`;
        report += `⚠️ **WARNING**: IDS/IPS evasion techniques should only be used:\n`;
        report += `- On systems you own\n`;
        report += `- With explicit written authorization\n`;
        report += `- In controlled testing environments\n`;
        report += `- Following responsible disclosure practices\n\n`;
        
        return report;
    }
}

async function main() {
    if (process.argv.length < 3) {
        console.log('Usage: node ids_ips_evasion.js <target> <port>');
        console.log('Example: node ids_ips_evasion.js 192.168.1.100 80');
        console.log('\n⚠️ WARNING: Only use for authorized security testing!');
        process.exit(1);
    }
    
    const target = process.argv[2];
    const port = parseInt(process.argv[3]) || 80;
    
    const evader = new IDSIPSEvasion(target, port);
    
    // Test with sample payload
    const testPayload = 'GET /index.html HTTP/1.1';
    await evader.testEvasion(testPayload);
    
    const report = evader.generateReport();
    
    const filename = `ids_ips_evasion_${target.replace(/\./g, '_')}_${port}.md`;
    fs.writeFileSync(filename, report, 'utf8');
    
    console.log(`\n[+] IDS/IPS evasion testing complete`);
    console.log(`[+] Report saved to ${filename}`);
    console.log(`[!] WARNING: Only test systems you own or have permission to test!`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = IDSIPSEvasion;

