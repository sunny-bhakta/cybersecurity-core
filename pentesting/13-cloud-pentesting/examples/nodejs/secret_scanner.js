#!/usr/bin/env node
/**
 * Secret Scanner
 * Scans code repositories and files for exposed secrets and credentials.
 */

const fs = require('fs');
const path = require('path');

class SecretScanner {
    constructor(targetPath) {
        this.targetPath = targetPath;
        this.findings = [];
        this.patterns = {
            AWS_ACCESS_KEY: /AKIA[0-9A-Z]{16}/,
            AWS_SECRET_KEY: /aws_secret_access_key\s*=\s*["']?([A-Za-z0-9/+=]{40})["']?/i,
            API_KEY: /api[_-]?key\s*[:=]\s*["']?([A-Za-z0-9]{20,})["']?/i,
            PRIVATE_KEY: /-----BEGIN\s+(RSA\s+)?PRIVATE\s+KEY-----/,
            PASSWORD: /password\s*[:=]\s*["']?([^"'\s]{8,})["']?/i,
            TOKEN: /token\s*[:=]\s*["']?([A-Za-z0-9]{20,})["']?/i,
            SECRET: /secret\s*[:=]\s*["']?([A-Za-z0-9]{20,})["']?/i,
            DATABASE_URL: /(postgres|mysql|mongodb):\/\/[^\s"']+/i,
            GITHUB_TOKEN: /ghp_[A-Za-z0-9]{36}/,
            SLACK_TOKEN: /xox[baprs]-[0-9a-zA-Z-]{10,}/,
            STRIPE_KEY: /sk_live_[0-9a-zA-Z]{24,}/
        };
    }

    scanFile(filePath) {
        const findings = [];
        
        try {
            const content = fs.readFileSync(filePath, 'utf8');
            const lines = content.split('\n');
            
            lines.forEach((line, lineNum) => {
                Object.entries(this.patterns).forEach(([secretType, pattern]) => {
                    const matches = line.matchAll(new RegExp(pattern, 'gi'));
                    for (const match of matches) {
                        let secretValue = match[0];
                        if (secretValue.length > 20) {
                            secretValue = secretValue.substring(0, 10) + '...' + secretValue.substring(secretValue.length - 5);
                        } else {
                            secretValue = '***';
                        }
                        
                        findings.push({
                            severity: 'High',
                            type: secretType,
                            file: filePath,
                            line: lineNum + 1,
                            match: secretValue,
                            description: `Potential ${secretType} found`
                        });
                    }
                });
            });
        } catch (err) {
            console.log(`[-] Error scanning ${filePath}: ${err.message}`);
        }
        
        return findings;
    }

    scanDirectory(directory) {
        console.log(`[*] Scanning directory: ${directory}...`);
        
        const findings = [];
        const excludedDirs = new Set(['.git', 'node_modules', '.venv', 'venv', '__pycache__', '.pytest_cache']);
        const excludedExts = new Set(['.pyc', '.pyo', '.pyd', '.so', '.dll', '.exe', '.jpg', '.png', '.gif']);
        
        function walkDir(dir) {
            const files = fs.readdirSync(dir);
            
            files.forEach(file => {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                
                if (stat.isDirectory()) {
                    if (!excludedDirs.has(file)) {
                        walkDir(filePath);
                    }
                } else {
                    const ext = path.extname(file);
                    if (!excludedExts.has(ext)) {
                        findings.push(...this.scanFile(filePath));
                    }
                }
            });
        }
        
        walkDir.call(this, directory);
        return findings;
    }

    scan() {
        const stat = fs.statSync(this.targetPath);
        
        if (stat.isFile()) {
            this.findings = this.scanFile(this.targetPath);
        } else if (stat.isDirectory()) {
            this.findings = this.scanDirectory(this.targetPath);
        } else {
            console.log(`[-] Path not found: ${this.targetPath}`);
            return {};
        }
        
        return {
            findings: this.findings,
            totalSecrets: this.findings.length
        };
    }

    generateReport() {
        let report = `# Secret Scanner Report\n\n`;
        report += `**Target**: ${this.targetPath}\n\n`;
        
        if (this.findings.length > 0) {
            report += `## Summary\n\n`;
            report += `**Total Secrets Found**: ${this.findings.length}\n\n`;
            
            const byType = {};
            this.findings.forEach(finding => {
                if (!byType[finding.type]) {
                    byType[finding.type] = [];
                }
                byType[finding.type].push(finding);
            });
            
            report += `## Findings by Type\n\n`;
            Object.entries(byType).forEach(([secretType, findings]) => {
                report += `### ${secretType}: ${findings.length} found\n\n`;
            });
            
            report += `## Detailed Findings\n\n`;
            this.findings.slice(0, 50).forEach((finding, i) => {
                report += `### ${i + 1}. ${finding.type}\n\n`;
                report += `**File**: \`${finding.file}\`\n\n`;
                report += `**Line**: ${finding.line}\n\n`;
                report += `**Match**: \`${finding.match}\`\n\n`;
                report += `**Description**: ${finding.description}\n\n`;
                report += `---\n\n`;
            });
            
            if (this.findings.length > 50) {
                report += `\n*... and ${this.findings.length - 50} more findings*\n\n`;
            }
        } else {
            report += `âœ… No secrets found.\n\n`;
        }
        
        report += `## Recommendations\n\n`;
        report += `1. Remove secrets from code immediately\n`;
        report += `2. Rotate all exposed credentials\n`;
        report += `3. Use environment variables or secret managers\n`;
        report += `4. Add secrets to .gitignore\n`;
        report += `5. Use pre-commit hooks to prevent commits\n`;
        report += `6. Enable secret scanning in CI/CD\n`;
        report += `7. Review git history for exposed secrets\n\n`;
        
        return report;
    }
}

function main() {
    if (process.argv.length < 3) {
        console.log('Usage: node secret_scanner.js <file_or_directory>');
        console.log('Example: node secret_scanner.js /path/to/repo');
        console.log('Example: node secret_scanner.js config.json');
        process.exit(1);
    }
    
    const targetPath = process.argv[2];
    
    const scanner = new SecretScanner(targetPath);
    scanner.scan();
    
    const report = scanner.generateReport();
    
    const filename = 'secret_scan_report.md';
    fs.writeFileSync(filename, report, 'utf8');
    
    console.log(`[+] Secret scan complete`);
    console.log(`[+] Report saved to ${filename}`);
    console.log(`[!] Found ${scanner.findings.length} potential secrets`);
    console.log('[!] WARNING: Review findings and rotate any exposed credentials!');
}

if (require.main === module) {
    main();
}

module.exports = SecretScanner;

