/**
 * S3 Bucket Scanner
 * Scans for publicly accessible S3 buckets and checks for misconfigurations.
 */

const https = require('https');
const http = require('http');
const { URL } = require('url');
const fs = require('fs');

class S3BucketScanner {
    constructor() {
        this.publicBuckets = [];
        this.vulnerableBuckets = [];
    }

    async makeRequest(url, method = 'GET', data = null) {
        return new Promise((resolve, reject) => {
            const urlObj = new URL(url);
            const protocol = urlObj.protocol === 'https:' ? https : http;

            const options = {
                hostname: urlObj.hostname,
                port: urlObj.port || (urlObj.protocol === 'https:' ? 443 : 80),
                path: urlObj.pathname + urlObj.search,
                method: method,
                timeout: 5000
            };

            const req = protocol.request(options, (res) => {
                let responseData = '';
                res.on('data', (chunk) => { responseData += chunk; });
                res.on('end', () => {
                    resolve({
                        statusCode: res.statusCode,
                        headers: res.headers,
                        body: responseData
                    });
                });
            });

            req.on('error', reject);
            req.on('timeout', () => {
                req.destroy();
                reject(new Error('Timeout'));
            });

            if (data) {
                req.write(data);
            }

            req.end();
        });
    }

    async checkBucketExists(bucketName) {
        try {
            const url = `https://${bucketName}.s3.amazonaws.com`;
            const response = await this.makeRequest(url);
            return response.statusCode !== 404;
        } catch (error) {
            try {
                const url = `http://${bucketName}.s3.amazonaws.com`;
                const response = await this.makeRequest(url);
                return response.statusCode !== 404;
            } catch (e) {
                return false;
            }
        }
    }

    async checkBucketPublic(bucketName) {
        const result = {
            bucket: bucketName,
            public: false,
            listable: false,
            readable: false,
            writable: false,
            details: {}
        };

        // Test public read access
        try {
            const url = `https://${bucketName}.s3.amazonaws.com`;
            const response = await this.makeRequest(url);

            if (response.statusCode === 200) {
                result.public = true;
                result.listable = true;
                result.details.list_response = response.body.substring(0, 500);
            }
        } catch (error) {
            // Continue
        }

        // Test if we can list objects
        try {
            const url = `https://${bucketName}.s3.amazonaws.com/?list-type=2`;
            const response = await this.makeRequest(url);

            if (response.statusCode === 200) {
                result.listable = true;
                result.details.object_list = response.body.substring(0, 1000);
            }
        } catch (error) {
            // Continue
        }

        // Test write access (dangerous - use carefully)
        try {
            const url = `https://${bucketName}.s3.amazonaws.com/test-write-check.txt`;
            const response = await this.makeRequest(url, 'PUT', 'test');

            if (response.statusCode === 200 || response.statusCode === 204) {
                result.writable = true;
                // Clean up test file
                await this.makeRequest(url, 'DELETE');
            }
        } catch (error) {
            // Continue
        }

        if (result.public || result.listable || result.readable) {
            this.publicBuckets.push(result);
            if (result.writable) {
                this.vulnerableBuckets.push(result);
            }
        }

        return result;
    }

    async scanBucket(bucketName) {
        console.log(`[*] Scanning bucket: ${bucketName}`);

        const result = {
            bucket: bucketName,
            exists: false,
            public_check: null,
            objects: []
        };

        result.exists = await this.checkBucketExists(bucketName);
        if (!result.exists) {
            console.log(`[-] Bucket does not exist or is not accessible`);
            return result;
        }

        console.log(`[+] Bucket exists`);

        result.public_check = await this.checkBucketPublic(bucketName);

        return result;
    }

    generateReport() {
        let report = `# S3 Bucket Security Scan Report\n\n`;
        report += `## Summary\n\n`;
        report += `Public Buckets Found: ${this.publicBuckets.length}\n`;
        report += `Writable Buckets: ${this.vulnerableBuckets.length}\n\n`;

        report += `## Public Buckets\n\n`;
        this.publicBuckets.forEach(bucket => {
            report += `### ${bucket.bucket}\n\n`;
            report += `- **Public**: ${bucket.public}\n`;
            report += `- **Listable**: ${bucket.listable}\n`;
            report += `- **Readable**: ${bucket.readable}\n`;
            report += `- **Writable**: ${bucket.writable}\n\n`;
        });

        if (this.vulnerableBuckets.length > 0) {
            report += `## ⚠️ CRITICAL: Writable Buckets\n\n`;
            this.vulnerableBuckets.forEach(bucket => {
                report += `- **${bucket.bucket}**: Publicly writable!\n`;
            });
        }

        return report;
    }
}

async function main() {
    const args = process.argv.slice(2);
    if (args.length < 1) {
        console.log('Usage: node s3_bucket_scanner.js <bucket_name> [bucket_name2] ...');
        console.log('Example: node s3_bucket_scanner.js my-bucket test-bucket');
        process.exit(1);
    }

    const scanner = new S3BucketScanner();
    const bucketNames = args;

    console.log(`[*] Scanning ${bucketNames.length} bucket(s)\n`);

    for (const bucketName of bucketNames) {
        await scanner.scanBucket(bucketName);
        console.log();
    }

    const report = scanner.generateReport();
    fs.writeFileSync('s3_scan_report.md', report, 'utf8');

    console.log(`[+] Report saved to s3_scan_report.md`);
    console.log(`[!] WARNING: Only test buckets you own or have permission to test!`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = S3BucketScanner;

