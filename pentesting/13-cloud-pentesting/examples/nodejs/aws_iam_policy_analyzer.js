#!/usr/bin/env node
/**
 * AWS IAM Policy Analyzer
 * Analyzes AWS IAM policies for security misconfigurations and vulnerabilities.
 */

const fs = require('fs');

class AWSIAMPolicyAnalyzer {
    constructor(policyFile = null) {
        this.policyFile = policyFile;
        this.findings = [];
    }

    loadPolicy(policyContent) {
        try {
            if (typeof policyContent === 'string') {
                return JSON.parse(policyContent);
            }
            return policyContent;
        } catch (err) {
            console.log(`[-] Error parsing policy JSON: ${err.message}`);
            return {};
        }
    }

    analyzePolicy(policy) {
        console.log('[*] Analyzing IAM policy...');
        
        const findings = [];
        
        if (!policy || Object.keys(policy).length === 0) {
            return findings;
        }
        
        let statements = policy.Statement || [];
        if (!Array.isArray(statements)) {
            statements = [statements];
        }
        
        statements.forEach((statement, i) => {
            let actions = statement.Action || [];
            if (!Array.isArray(actions)) {
                actions = [actions];
            }
            
            if (actions.includes('*') || actions.includes('s3:*') || actions.includes('ec2:*')) {
                findings.push({
                    severity: 'High',
                    issue: `Overly Permissive Actions (Statement ${i + 1})`,
                    description: `Policy allows wildcard or overly broad actions: ${actions.join(', ')}`,
                    statement: i + 1
                });
            }
            
            let resources = statement.Resource || [];
            if (!Array.isArray(resources)) {
                resources = [resources];
            }
            
            if (resources.includes('*')) {
                findings.push({
                    severity: 'Critical',
                    issue: `Wildcard Resource (Statement ${i + 1})`,
                    description: 'Policy allows access to all resources (*)',
                    statement: i + 1
                });
            }
            
            if (!statement.Condition) {
                if (actions.includes('*') || resources.includes('*')) {
                    findings.push({
                        severity: 'Medium',
                        issue: `Missing Conditions (Statement ${i + 1})`,
                        description: 'Policy lacks conditions to restrict access',
                        statement: i + 1
                    });
                }
            }
            
            if (statement.Effect === 'Allow' && statement.NotAction) {
                findings.push({
                    severity: 'High',
                    issue: `Allow with NotAction (Statement ${i + 1})`,
                    description: 'Allow with NotAction can be overly permissive',
                    statement: i + 1
                });
            }
        });
        
        return findings;
    }

    checkLeastPrivilege(policy) {
        console.log('[*] Checking principle of least privilege...');
        
        const findings = [];
        let statements = policy.Statement || [];
        if (!Array.isArray(statements)) {
            statements = [statements];
        }
        
        statements.forEach((statement, i) => {
            let actions = statement.Action || [];
            if (!Array.isArray(actions)) {
                actions = [actions];
            }
            
            const adminActions = ['*', 'iam:*', 'cloudformation:*', 'lambda:*'];
            if (actions.some(action => adminActions.includes(action))) {
                findings.push({
                    severity: 'High',
                    issue: `Admin-Level Permissions (Statement ${i + 1})`,
                    description: 'Policy grants administrative permissions',
                    statement: i + 1
                });
            }
        });
        
        return findings;
    }

    analyzeAll(policyContent) {
        const policy = this.loadPolicy(policyContent);
        
        if (!policy || Object.keys(policy).length === 0) {
            return {};
        }
        
        this.findings.push(...this.analyzePolicy(policy));
        this.findings.push(...this.checkLeastPrivilege(policy));
        
        return {
            policy,
            findings: this.findings
        };
    }

    generateReport() {
        let report = `# AWS IAM Policy Analysis Report\n\n`;
        
        if (this.findings.length > 0) {
            report += `## Summary\n\n`;
            report += `Total Findings: ${this.findings.length}\n\n`;
            
            const critical = this.findings.filter(f => f.severity === 'Critical');
            const high = this.findings.filter(f => f.severity === 'High');
            const medium = this.findings.filter(f => f.severity === 'Medium');
            
            report += `- **Critical**: ${critical.length}\n`;
            report += `- **High**: ${high.length}\n`;
            report += `- **Medium**: ${medium.length}\n\n`;
            
            report += `## Findings\n\n`;
            this.findings.forEach((finding, i) => {
                report += `### ${i + 1}. ${finding.issue}\n\n`;
                report += `**Severity**: ${finding.severity}\n\n`;
                report += `**Description**: ${finding.description}\n\n`;
                if (finding.statement) {
                    report += `**Statement**: ${finding.statement}\n\n`;
                }
                report += `---\n\n`;
            });
        } else {
            report += `âœ… No security issues found.\n\n`;
        }
        
        report += `## Best Practices\n\n`;
        report += `1. Follow principle of least privilege\n`;
        report += `2. Avoid wildcard resources (*)\n`;
        report += `3. Use specific actions instead of wildcards\n`;
        report += `4. Implement conditions to restrict access\n`;
        report += `5. Regularly review and audit policies\n`;
        report += `6. Use IAM Access Analyzer\n`;
        report += `7. Enable CloudTrail for audit logging\n\n`;
        
        return report;
    }
}

function main() {
    if (process.argv.length < 3) {
        console.log('Usage: node aws_iam_policy_analyzer.js <policy_file>');
        console.log('Example: node aws_iam_policy_analyzer.js policy.json');
        console.log('\nOr provide policy JSON as stdin:');
        console.log('cat policy.json | node aws_iam_policy_analyzer.js -');
        process.exit(1);
    }
    
    const policyFile = process.argv[2];
    let policyContent;
    
    if (policyFile === '-') {
        policyContent = fs.readFileSync(0, 'utf8');
    } else {
        try {
            policyContent = fs.readFileSync(policyFile, 'utf8');
        } catch (err) {
            console.log(`[-] Policy file not found: ${policyFile}`);
            process.exit(1);
        }
    }
    
    const analyzer = new AWSIAMPolicyAnalyzer(policyFile);
    analyzer.analyzeAll(policyContent);
    
    const report = analyzer.generateReport();
    
    const filename = 'aws_iam_policy_analysis.md';
    fs.writeFileSync(filename, report, 'utf8');
    
    console.log(`[+] IAM policy analysis complete`);
    console.log(`[+] Report saved to ${filename}`);
}

if (require.main === module) {
    main();
}

module.exports = AWSIAMPolicyAnalyzer;

