#!/usr/bin/env node
/**
 * GCP Security Scanner
 * Scans Google Cloud Platform resources for security misconfigurations.
 */

const fs = require('fs');

class GCPSecurityScanner {
    constructor(projectId = null) {
        this.projectId = projectId;
        this.findings = [];
    }

    checkStorageBucketSecurity(bucket) {
        console.log('[*] Checking Storage Bucket security...');
        
        const findings = [];
        
        const iamPolicy = bucket.iamConfiguration?.publicAccessPrevention || 'inherited';
        if (iamPolicy === 'enforced') {
            const bindings = bucket.iam?.bindings || [];
            bindings.forEach(binding => {
                const members = binding.members || [];
                if (members.includes('allUsers') || members.includes('allAuthenticatedUsers')) {
                    findings.push({
                        severity: 'High',
                        issue: 'Public Bucket Access',
                        description: 'Bucket is publicly accessible',
                        resource: bucket.name || 'Unknown'
                    });
                }
            });
        }
        
        if (bucket.versioning?.enabled !== true) {
            findings.push({
                severity: 'Medium',
                issue: 'Versioning Not Enabled',
                description: 'Bucket versioning is not enabled',
                resource: bucket.name || 'Unknown'
            });
        }
        
        return findings;
    }

    checkComputeInstanceSecurity(instance) {
        console.log('[*] Checking Compute Instance security...');
        
        const findings = [];
        
        const networkInterfaces = instance.networkInterfaces || [];
        networkInterfaces.forEach(ni => {
            const accessConfigs = ni.accessConfigs || [];
            if (accessConfigs.length > 0) {
                findings.push({
                    severity: 'Medium',
                    issue: 'Public IP Assigned',
                    description: 'Instance has public IP address',
                    resource: instance.name || 'Unknown'
                });
            }
        });
        
        const serviceAccounts = instance.serviceAccounts || [];
        if (serviceAccounts.length > 0) {
            const email = serviceAccounts[0].email || '';
            if (email.includes('default') || email.includes('compute@developer')) {
                findings.push({
                    severity: 'Medium',
                    issue: 'Default Service Account',
                    description: 'Instance uses default service account',
                    resource: instance.name || 'Unknown'
                });
            }
        }
        
        return findings;
    }

    checkSqlInstanceSecurity(sqlInstance) {
        console.log('[*] Checking SQL Instance security...');
        
        const findings = [];
        
        const ipAddresses = sqlInstance.ipAddresses || [];
        ipAddresses.forEach(ip => {
            if (ip.type === 'PRIMARY' && ip.ipAddress) {
                findings.push({
                    severity: 'High',
                    issue: 'Public IP Enabled',
                    description: 'SQL instance has public IP address',
                    resource: sqlInstance.name || 'Unknown'
                });
            }
        });
        
        if (sqlInstance.settings?.ipConfiguration?.requireSsl !== true) {
            findings.push({
                severity: 'High',
                issue: 'SSL Not Required',
                description: 'SQL instance does not require SSL',
                resource: sqlInstance.name || 'Unknown'
            });
        }
        
        return findings;
    }

    checkIamPolicy(policy) {
        console.log('[*] Checking IAM Policy...');
        
        const findings = [];
        
        const bindings = policy.bindings || [];
        bindings.forEach(binding => {
            const role = binding.role || '';
            const members = binding.members || [];
            
            if (role.includes('roles/owner') || role.includes('roles/editor')) {
                findings.push({
                    severity: 'High',
                    issue: `Overly Permissive Role: ${role}`,
                    description: `Role ${role} grants excessive permissions`,
                    resource: 'IAM Policy'
                });
            }
            
            if (members.includes('allUsers') || members.includes('allAuthenticatedUsers')) {
                findings.push({
                    severity: 'Critical',
                    issue: 'Public Access Granted',
                    description: `Public access granted with role: ${role}`,
                    resource: 'IAM Policy'
                });
            }
        });
        
        return findings;
    }

    scanResources(resources) {
        console.log('[*] Scanning GCP resources...');
        
        const buckets = resources.buckets || [];
        buckets.forEach(bucket => {
            this.findings.push(...this.checkStorageBucketSecurity(bucket));
        });
        
        const instances = resources.instances || [];
        instances.forEach(instance => {
            this.findings.push(...this.checkComputeInstanceSecurity(instance));
        });
        
        const sqlInstances = resources.sql_instances || [];
        sqlInstances.forEach(sqlInstance => {
            this.findings.push(...this.checkSqlInstanceSecurity(sqlInstance));
        });
        
        if (resources.iam_policy) {
            this.findings.push(...this.checkIamPolicy(resources.iam_policy));
        }
        
        return {
            findings: this.findings,
            resourcesScanned: buckets.length + instances.length + sqlInstances.length
        };
    }

    generateReport() {
        let report = `# GCP Security Scan Report\n\n`;
        
        if (this.projectId) {
            report += `**Project ID**: ${this.projectId}\n\n`;
        }
        
        if (this.findings.length > 0) {
            report += `## Summary\n\n`;
            report += `Total Findings: ${this.findings.length}\n\n`;
            
            const critical = this.findings.filter(f => f.severity === 'Critical');
            const high = this.findings.filter(f => f.severity === 'High');
            const medium = this.findings.filter(f => f.severity === 'Medium');
            
            report += `- **Critical**: ${critical.length}\n`;
            report += `- **High**: ${high.length}\n`;
            report += `- **Medium**: ${medium.length}\n\n`;
            
            report += `## Findings\n\n`;
            this.findings.forEach((finding, i) => {
                report += `### ${i + 1}. ${finding.issue}\n\n`;
                report += `**Severity**: ${finding.severity}\n\n`;
                report += `**Description**: ${finding.description}\n\n`;
                if (finding.resource) {
                    report += `**Resource**: ${finding.resource}\n\n`;
                }
                report += `---\n\n`;
            });
        } else {
            report += `âœ… No security issues found.\n\n`;
        }
        
        report += `## Best Practices\n\n`;
        report += `1. Use private IPs where possible\n`;
        report += `2. Enable VPC Flow Logs\n`;
        report += `3. Implement least privilege IAM\n`;
        report += `4. Enable Cloud Security Command Center\n`;
        report += `5. Use organization policies\n`;
        report += `6. Enable audit logging\n`;
        report += `7. Use service account keys securely\n\n`;
        
        return report;
    }
}

function main() {
    const projectId = process.argv[2] || null;
    
    const scanner = new GCPSecurityScanner(projectId);
    
    console.log('[!] Note: Real implementation requires GCP SDK');
    console.log('[!] Use: @google-cloud/resource-manager or gcloud CLI');
    
    const resources = {}; // Placeholder
    scanner.scanResources(resources);
    
    const report = scanner.generateReport();
    
    const filename = 'gcp_security_scan.md';
    fs.writeFileSync(filename, report, 'utf8');
    
    console.log(`[+] GCP security scan complete`);
    console.log(`[+] Report saved to ${filename}`);
}

if (require.main === module) {
    main();
}

module.exports = GCPSecurityScanner;

