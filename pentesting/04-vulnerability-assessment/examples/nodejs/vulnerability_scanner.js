/**
 * Vulnerability Scanner
 * Scans for common vulnerabilities and misconfigurations.
 */

const https = require('https');
const http = require('http');
const { URL } = require('url');
const fs = require('fs');

class VulnerabilityScanner {
    constructor(targetUrl) {
        this.targetUrl = targetUrl;
        this.vulnerabilities = [];
    }

    async makeRequest(url, method = 'GET', headers = {}) {
        return new Promise((resolve, reject) => {
            const urlObj = new URL(url);
            const protocol = urlObj.protocol === 'https:' ? https : http;
            
            const options = {
                hostname: urlObj.hostname,
                port: urlObj.port || (urlObj.protocol === 'https:' ? 443 : 80),
                path: urlObj.pathname + urlObj.search,
                method: method,
                headers: headers,
                timeout: 10000
            };

            const req = protocol.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => { data += chunk; });
                res.on('end', () => {
                    resolve({
                        statusCode: res.statusCode,
                        headers: res.headers,
                        body: data
                    });
                });
            });

            req.on('error', reject);
            req.on('timeout', () => {
                req.destroy();
                reject(new Error('Request timeout'));
            });

            req.end();
        });
    }

    async checkSecurityHeaders() {
        console.log('[*] Checking security headers...');
        const vulnerabilities = [];

        const requiredHeaders = {
            'X-Frame-Options': 'Prevents clickjacking',
            'X-Content-Type-Options': 'Prevents MIME sniffing',
            'X-XSS-Protection': 'XSS protection',
            'Strict-Transport-Security': 'HSTS enforcement',
            'Content-Security-Policy': 'CSP protection'
        };

        try {
            const response = await this.makeRequest(this.targetUrl);
            const headers = response.headers;

            for (const [header, description] of Object.entries(requiredHeaders)) {
                if (!headers[header.toLowerCase()]) {
                    const vuln = {
                        type: 'Missing Security Header',
                        severity: 'Medium',
                        header: header,
                        description: description,
                        recommendation: `Add ${header} header`
                    };
                    vulnerabilities.push(vuln);
                    console.log(`[-] Missing header: ${header}`);
                }
            }
        } catch (error) {
            console.log(`[-] Error checking headers: ${error.message}`);
        }

        return vulnerabilities;
    }

    async checkExposedFiles() {
        console.log('[*] Checking for exposed files...');
        const vulnerabilities = [];

        const sensitiveFiles = [
            '.env',
            '.git/config',
            'backup.sql',
            'config.php',
            'wp-config.php',
            'web.config',
            'robots.txt',
            '.htaccess',
            'phpinfo.php',
            'info.php'
        ];

        for (const filePath of sensitiveFiles) {
            try {
                const url = new URL(filePath, this.targetUrl).href;
                const response = await this.makeRequest(url);

                if (response.statusCode === 200 && response.body.length > 50) {
                    const vuln = {
                        type: 'Exposed File',
                        severity: 'High',
                        file: filePath,
                        url: url,
                        description: `Exposed file found: ${filePath}`,
                        recommendation: 'Remove or restrict access to sensitive files'
                    };
                    vulnerabilities.push(vuln);
                    console.log(`[+] Exposed file found: ${filePath}`);
                }
            } catch (error) {
                // File doesn't exist or error accessing
            }
        }

        return vulnerabilities;
    }

    async checkServerInfoDisclosure() {
        console.log('[*] Checking for information disclosure...');
        const vulnerabilities = [];

        try {
            const response = await this.makeRequest(this.targetUrl);
            const headers = response.headers;

            if (headers['server']) {
                const vuln = {
                    type: 'Information Disclosure',
                    severity: 'Low',
                    header: 'Server',
                    value: headers['server'],
                    description: `Server information disclosed: ${headers['server']}`,
                    recommendation: 'Remove or obfuscate Server header'
                };
                vulnerabilities.push(vuln);
                console.log(`[+] Server information disclosed: ${headers['server']}`);
            }

            if (headers['x-powered-by']) {
                const vuln = {
                    type: 'Information Disclosure',
                    severity: 'Low',
                    header: 'X-Powered-By',
                    value: headers['x-powered-by'],
                    description: `Technology stack disclosed: ${headers['x-powered-by']}`,
                    recommendation: 'Remove X-Powered-By header'
                };
                vulnerabilities.push(vuln);
                console.log(`[+] Technology stack disclosed: ${headers['x-powered-by']}`);
            }
        } catch (error) {
            console.log(`[-] Error checking information disclosure: ${error.message}`);
        }

        return vulnerabilities;
    }

    async checkHttpMethods() {
        console.log('[*] Checking HTTP methods...');
        const vulnerabilities = [];

        const dangerousMethods = ['PUT', 'DELETE', 'TRACE', 'CONNECT', 'PATCH'];

        try {
            const response = await this.makeRequest(this.targetUrl, 'OPTIONS');
            if (response.headers['allow']) {
                const allowedMethods = response.headers['allow'].split(', ');

                for (const method of dangerousMethods) {
                    if (allowedMethods.includes(method)) {
                        const vuln = {
                            type: 'Dangerous HTTP Method',
                            severity: 'Medium',
                            method: method,
                            description: `Dangerous HTTP method enabled: ${method}`,
                            recommendation: `Disable ${method} method if not needed`
                        };
                        vulnerabilities.push(vuln);
                        console.log(`[-] Dangerous method enabled: ${method}`);
                    }
                }
            }
        } catch (error) {
            console.log(`[-] Error checking HTTP methods: ${error.message}`);
        }

        return vulnerabilities;
    }

    async scanAll() {
        console.log(`[*] Starting vulnerability scan on ${this.targetUrl}\n`);

        this.vulnerabilities.push(...await this.checkSecurityHeaders());
        this.vulnerabilities.push(...await this.checkExposedFiles());
        this.vulnerabilities.push(...await this.checkServerInfoDisclosure());
        this.vulnerabilities.push(...await this.checkHttpMethods());

        return this.vulnerabilities;
    }

    generateReport() {
        let report = `# Vulnerability Assessment Report\n\n`;
        report += `**Target**: ${this.targetUrl}\n\n`;
        report += `## Summary\n\n`;
        report += `Total Vulnerabilities Found: ${this.vulnerabilities.length}\n\n`;

        const critical = this.vulnerabilities.filter(v => v.severity === 'Critical');
        const high = this.vulnerabilities.filter(v => v.severity === 'High');
        const medium = this.vulnerabilities.filter(v => v.severity === 'Medium');
        const low = this.vulnerabilities.filter(v => v.severity === 'Low');

        report += `- **Critical**: ${critical.length}\n`;
        report += `- **High**: ${high.length}\n`;
        report += `- **Medium**: ${medium.length}\n`;
        report += `- **Low**: ${low.length}\n\n`;

        report += `## Vulnerabilities\n\n`;
        this.vulnerabilities.forEach((vuln, i) => {
            report += `### ${i + 1}. ${vuln.type}\n\n`;
            report += `**Severity**: ${vuln.severity}\n\n`;
            report += `**Description**: ${vuln.description}\n\n`;
            report += `**Recommendation**: ${vuln.recommendation}\n\n`;
            if (vuln.url) {
                report += `**URL**: ${vuln.url}\n\n`;
            }
            report += `---\n\n`;
        });

        return report;
    }
}

async function main() {
    const args = process.argv.slice(2);
    if (args.length < 1) {
        console.log('Usage: node vulnerability_scanner.js <target_url>');
        console.log('Example: node vulnerability_scanner.js http://example.com');
        process.exit(1);
    }

    const targetUrl = args[0];
    const scanner = new VulnerabilityScanner(targetUrl);

    await scanner.scanAll();

    const report = scanner.generateReport();
    fs.writeFileSync('vulnerability_report.md', report, 'utf8');

    console.log(`\n[+] Scan complete. Found ${scanner.vulnerabilities.length} vulnerabilities`);
    console.log(`[+] Report saved to vulnerability_report.md`);
    console.log(`[!] WARNING: Only test on systems you own or have permission to test!`);
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = VulnerabilityScanner;

